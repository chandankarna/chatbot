{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return root['Autolinker'] = factory();\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Autolinker'] = factory();\n  }\n})(this, function () {\n  /*!\n   * Autolinker.js\n   * 0.19.1\n   *\n   * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n   * MIT\n   *\n   * https://github.com/gregjacobs/Autolinker.js\n   */\n  /**\n   * @class Autolinker\n   * @extends Object\n   *\n   * Utility class used to process a given string of text, and wrap the matches in\n   * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n   *\n   * Any of the configuration options may be provided in an Object (map) provided\n   * to the Autolinker constructor, which will configure how the {@link #link link()}\n   * method will process the links.\n   *\n   * For example:\n   *\n   *     var autolinker = new Autolinker( {\n   *         newWindow : false,\n   *         truncate  : 30\n   *     } );\n   *\n   *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n   *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n   *\n   *\n   * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n   * be more convenient for one-off uses. For example:\n   *\n   *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n   *         newWindow : false,\n   *         truncate  : 30\n   *     } );\n   *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n   *\n   *\n   * ## Custom Replacements of Links\n   *\n   * If the configuration options do not provide enough flexibility, a {@link #replaceFn}\n   * may be provided to fully customize the output of Autolinker. This function is\n   * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is\n   * encountered.\n   *\n   * For example:\n   *\n   *     var input = \"...\";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags\n   *\n   *     var linkedText = Autolinker.link( input, {\n   *         replaceFn : function( autolinker, match ) {\n   *             console.log( \"href = \", match.getAnchorHref() );\n   *             console.log( \"text = \", match.getAnchorText() );\n   *\n   *             switch( match.getType() ) {\n   *                 case 'url' :\n   *                     console.log( \"url: \", match.getUrl() );\n   *\n   *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n   *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n   *                         tag.setAttr( 'rel', 'nofollow' );\n   *                         tag.addClass( 'external-link' );\n   *\n   *                         return tag;\n   *\n   *                     } else {\n   *                         return true;  // let Autolinker perform its normal anchor tag replacement\n   *                     }\n   *\n   *                 case 'email' :\n   *                     var email = match.getEmail();\n   *                     console.log( \"email: \", email );\n   *\n   *                     if( email === \"my@own.address\" ) {\n   *                         return false;  // don't auto-link this particular email address; leave as-is\n   *                     } else {\n   *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n   *                     }\n   *\n   *                 case 'phone' :\n   *                     var phoneNumber = match.getPhoneNumber();\n   *                     console.log( phoneNumber );\n   *\n   *                     return '<a href=\"http://newplace.to.link.phone.numbers.to/\">' + phoneNumber + '</a>';\n   *\n   *                 case 'twitter' :\n   *                     var twitterHandle = match.getTwitterHandle();\n   *                     console.log( twitterHandle );\n   *\n   *                     return '<a href=\"http://newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n   *\n   *                 case 'hashtag' :\n   *                     var hashtag = match.getHashtag();\n   *                     console.log( hashtag );\n   *\n   *                     return '<a href=\"http://newplace.to.link.hashtag.handles.to/\">' + hashtag + '</a>';\n   *             }\n   *         }\n   *     } );\n   *\n   *\n   * The function may return the following values:\n   *\n   * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n   * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n   * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n   *   the match.\n   * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n   *\n   * @constructor\n   * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n   */\n  var Autolinker = function (cfg) {\n    Autolinker.Util.assign(this, cfg); // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n\n    // Validate the value of the `hashtag` cfg.\n    var hashtag = this.hashtag;\n    if (hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram') {\n      throw new Error(\"invalid `hashtag` cfg - see docs\");\n    }\n  };\n  Autolinker.prototype = {\n    constructor: Autolinker,\n    // fix constructor property\n\n    /**\n     * @cfg {Boolean} urls\n     *\n     * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n     */\n    urls: true,\n    /**\n     * @cfg {Boolean} email\n     *\n     * `true` if email addresses should be automatically linked, `false` if they should not be.\n     */\n    email: true,\n    /**\n     * @cfg {Boolean} twitter\n     *\n     * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n     */\n    twitter: true,\n    /**\n     * @cfg {Boolean} phone\n     *\n     * `true` if Phone numbers (\"(555)555-5555\") should be automatically linked, `false` if they should not be.\n     */\n    phone: true,\n    /**\n     * @cfg {Boolean/String} hashtag\n     *\n     * A string for the service name to have hashtags (ex: \"#myHashtag\")\n     * auto-linked to. The currently-supported values are:\n     *\n     * - 'twitter'\n     * - 'facebook'\n     * - 'instagram'\n     *\n     * Pass `false` to skip auto-linking of hashtags.\n     */\n    hashtag: false,\n    /**\n     * @cfg {Boolean} newWindow\n     *\n     * `true` if the links should open in a new window, `false` otherwise.\n     */\n    newWindow: true,\n    /**\n     * @cfg {Boolean} stripPrefix\n     *\n     * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped\n     * from the beginning of URL links' text, `false` otherwise.\n     */\n    stripPrefix: true,\n    /**\n     * @cfg {Number} truncate\n     *\n     * A number for how many characters long matched text should be truncated to inside the text of\n     * a link. If the matched text is over this number of characters, it will be truncated to this length by\n     * adding a two period ellipsis ('..') to the end of the string.\n     *\n     * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n     * something like this: 'yahoo.com/some/long/pat..'\n     */\n    truncate: undefined,\n    /**\n     * @cfg {String} className\n     *\n     * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n     * plus match suffixes for styling url/email/phone/twitter/hashtag links differently.\n     *\n     * For example, if this config is provided as \"myLink\", then:\n     *\n     * - URL links will have the CSS classes: \"myLink myLink-url\"\n     * - Email links will have the CSS classes: \"myLink myLink-email\", and\n     * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n     * - Phone links will have the CSS classes: \"myLink myLink-phone\"\n     * - Hashtag links will have the CSS classes: \"myLink myLink-hashtag\"\n     */\n    className: \"\",\n    /**\n     * @cfg {Function} replaceFn\n     *\n     * A function to individually process each match found in the input string.\n     *\n     * See the class's description for usage.\n     *\n     * This function is called with the following parameters:\n     *\n     * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n     *   as the instance's {@link #getTagBuilder tag builder}).\n     * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n     *   match that the `replaceFn` is currently processing. See {@link Autolinker.match.Match} subclasses for details.\n     */\n\n    /**\n     * @private\n     * @property {Autolinker.htmlParser.HtmlParser} htmlParser\n     *\n     * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n     * in the {@link #getHtmlParser} method.\n     */\n    htmlParser: undefined,\n    /**\n     * @private\n     * @property {Autolinker.matchParser.MatchParser} matchParser\n     *\n     * The MatchParser instance used to find matches in the text nodes of an input string passed to\n     * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.\n     */\n    matchParser: undefined,\n    /**\n     * @private\n     * @property {Autolinker.AnchorTagBuilder} tagBuilder\n     *\n     * The AnchorTagBuilder instance used to build match replacement anchor tags. Note: this is lazily instantiated\n     * in the {@link #getTagBuilder} method.\n     */\n    tagBuilder: undefined,\n    /**\n     * Automatically links URLs, Email addresses, Phone numbers, Twitter\n     * handles, and Hashtags found in the given chunk of HTML. Does not link\n     * URLs found within HTML tags.\n     *\n     * For instance, if given the text: `You should go to http://www.yahoo.com`,\n     * then the result will be `You should go to\n     * &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n     *\n     * This method finds the text around any HTML elements in the input\n     * `textOrHtml`, which will be the text that is processed. Any original HTML\n     * elements will be left as-is, as well as the text that is already wrapped\n     * in anchor (&lt;a&gt;) tags.\n     *\n     * @param {String} textOrHtml The HTML or text to autolink matches within\n     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n     *   {@link #twitter}, and {@link #hashtag} options are enabled).\n     * @return {String} The HTML, with matches automatically linked.\n     */\n    link: function (textOrHtml) {\n      if (!textOrHtml) {\n        return \"\";\n      } // handle `null` and `undefined`\n\n      var htmlParser = this.getHtmlParser(),\n        htmlNodes = htmlParser.parse(textOrHtml),\n        anchorTagStackCount = 0,\n        // used to only process text around anchor tags, and any inner text/html they may have\n        resultHtml = [];\n      for (var i = 0, len = htmlNodes.length; i < len; i++) {\n        var node = htmlNodes[i],\n          nodeType = node.getType(),\n          nodeText = node.getText();\n        if (nodeType === 'element') {\n          // Process HTML nodes in the input `textOrHtml`\n          if (node.getTagName() === 'a') {\n            if (!node.isClosing()) {\n              // it's the start <a> tag\n              anchorTagStackCount++;\n            } else {\n              // it's the end </a> tag\n              anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n            }\n          }\n          resultHtml.push(nodeText); // now add the text of the tag itself verbatim\n        } else if (nodeType === 'entity' || nodeType === 'comment') {\n          resultHtml.push(nodeText); // append HTML entity nodes (such as '&nbsp;') or HTML comments (such as '<!-- Comment -->') verbatim\n        } else {\n          // Process text nodes in the input `textOrHtml`\n          if (anchorTagStackCount === 0) {\n            // If we're not within an <a> tag, process the text node to linkify\n            var linkifiedStr = this.linkifyStr(nodeText);\n            resultHtml.push(linkifiedStr);\n          } else {\n            // `text` is within an <a> tag, simply append the text - we do not want to autolink anything\n            // already within an <a>...</a> tag\n            resultHtml.push(nodeText);\n          }\n        }\n      }\n      return resultHtml.join(\"\");\n    },\n    /**\n     * Process the text that lies in between HTML tags, performing the anchor\n     * tag replacements for the matches, and returns the string with the\n     * replacements made.\n     *\n     * This method does the actual wrapping of matches with anchor tags.\n     *\n     * @private\n     * @param {String} str The string of text to auto-link.\n     * @return {String} The text with anchor tags auto-filled.\n     */\n    linkifyStr: function (str) {\n      return this.getMatchParser().replace(str, this.createMatchReturnVal, this);\n    },\n    /**\n     * Creates the return string value for a given match in the input string,\n     * for the {@link #linkifyStr} method.\n     *\n     * This method handles the {@link #replaceFn}, if one was provided.\n     *\n     * @private\n     * @param {Autolinker.match.Match} match The Match object that represents the match.\n     * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n     *   may be the `matchStr` itself if the match is not to be replaced.\n     */\n    createMatchReturnVal: function (match) {\n      // Handle a custom `replaceFn` being provided\n      var replaceFnResult;\n      if (this.replaceFn) {\n        replaceFnResult = this.replaceFn.call(this, this, match); // Autolinker instance is the context, and the first arg\n      }\n      if (typeof replaceFnResult === 'string') {\n        return replaceFnResult; // `replaceFn` returned a string, use that\n      } else if (replaceFnResult === false) {\n        return match.getMatchedText(); // no replacement for the match\n      } else if (replaceFnResult instanceof Autolinker.HtmlTag) {\n        return replaceFnResult.toAnchorString();\n      } else {\n        // replaceFnResult === true, or no/unknown return value from function\n        // Perform Autolinker's default anchor tag generation\n        var tagBuilder = this.getTagBuilder(),\n          anchorTag = tagBuilder.build(match); // returns an Autolinker.HtmlTag instance\n\n        return anchorTag.toAnchorString();\n      }\n    },\n    /**\n     * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n     *\n     * @protected\n     * @return {Autolinker.htmlParser.HtmlParser}\n     */\n    getHtmlParser: function () {\n      var htmlParser = this.htmlParser;\n      if (!htmlParser) {\n        htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();\n      }\n      return htmlParser;\n    },\n    /**\n     * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.\n     *\n     * @protected\n     * @return {Autolinker.matchParser.MatchParser}\n     */\n    getMatchParser: function () {\n      var matchParser = this.matchParser;\n      if (!matchParser) {\n        matchParser = this.matchParser = new Autolinker.matchParser.MatchParser({\n          urls: this.urls,\n          email: this.email,\n          twitter: this.twitter,\n          phone: this.phone,\n          hashtag: this.hashtag,\n          stripPrefix: this.stripPrefix\n        });\n      }\n      return matchParser;\n    },\n    /**\n     * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n     * if it does not yet exist.\n     *\n     * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n     * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n     *\n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( autolinker, match ) {\n     *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n     *             tag.setAttr( 'rel', 'nofollow' );\n     *\n     *             return tag;\n     *         }\n     *     } );\n     *\n     *     // generated html:\n     *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n     *\n     * @return {Autolinker.AnchorTagBuilder}\n     */\n    getTagBuilder: function () {\n      var tagBuilder = this.tagBuilder;\n      if (!tagBuilder) {\n        tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder({\n          newWindow: this.newWindow,\n          truncate: this.truncate,\n          className: this.className\n        });\n      }\n      return tagBuilder;\n    }\n  };\n\n  /**\n   * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,\n   * and Hashtags found in the given chunk of HTML. Does not link URLs found\n   * within HTML tags.\n   *\n   * For instance, if given the text: `You should go to http://www.yahoo.com`,\n   * then the result will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n   *\n   * Example:\n   *\n   *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n   *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n   *\n   * @static\n   * @param {String} textOrHtml The HTML or text to find matches within (depending\n   *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},\n   *   and {@link #hashtag} options are enabled).\n   * @param {Object} [options] Any of the configuration options for the Autolinker\n   *   class, specified in an Object (map). See the class description for an\n   *   example call.\n   * @return {String} The HTML text, with matches automatically linked.\n   */\n  Autolinker.link = function (textOrHtml, options) {\n    var autolinker = new Autolinker(options);\n    return autolinker.link(textOrHtml);\n  };\n\n  // Autolinker Namespaces\n  Autolinker.match = {};\n  Autolinker.htmlParser = {};\n  Autolinker.matchParser = {};\n\n  /*global Autolinker */\n  /*jshint eqnull:true, boss:true */\n  /**\n   * @class Autolinker.Util\n   * @singleton\n   *\n   * A few utility methods for Autolinker.\n   */\n  Autolinker.Util = {\n    /**\n     * @property {Function} abstractMethod\n     *\n     * A function object which represents an abstract method.\n     */\n    abstractMethod: function () {\n      throw \"abstract\";\n    },\n    /**\n     * @private\n     * @property {RegExp} trimRegex\n     *\n     * The regular expression used to trim the leading and trailing whitespace\n     * from a string.\n     */\n    trimRegex: /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n    /**\n     * Assigns (shallow copies) the properties of `src` onto `dest`.\n     *\n     * @param {Object} dest The destination object.\n     * @param {Object} src The source object.\n     * @return {Object} The destination object (`dest`)\n     */\n    assign: function (dest, src) {\n      for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n          dest[prop] = src[prop];\n        }\n      }\n      return dest;\n    },\n    /**\n     * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n     *\n     * @param {Function} superclass The constructor function for the superclass.\n     * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n     *   special property `constructor`, which will be used as the new subclass's constructor function.\n     * @return {Function} The new subclass function.\n     */\n    extend: function (superclass, protoProps) {\n      var superclassProto = superclass.prototype;\n      var F = function () {};\n      F.prototype = superclassProto;\n      var subclass;\n      if (protoProps.hasOwnProperty('constructor')) {\n        subclass = protoProps.constructor;\n      } else {\n        subclass = function () {\n          superclassProto.constructor.apply(this, arguments);\n        };\n      }\n      var subclassProto = subclass.prototype = new F(); // set up prototype chain\n      subclassProto.constructor = subclass; // fix constructor property\n      subclassProto.superclass = superclassProto;\n      delete protoProps.constructor; // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n      Autolinker.Util.assign(subclassProto, protoProps);\n      return subclass;\n    },\n    /**\n     * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n     * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n     * `len`, the string will be returned unchanged.\n     *\n     * @param {String} str The string to truncate and add an ellipsis to.\n     * @param {Number} truncateLen The length to truncate the string at.\n     * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n     *   when truncated. Defaults to '..'\n     */\n    ellipsis: function (str, truncateLen, ellipsisChars) {\n      if (str.length > truncateLen) {\n        ellipsisChars = ellipsisChars == null ? '..' : ellipsisChars;\n        str = str.substring(0, truncateLen - ellipsisChars.length) + ellipsisChars;\n      }\n      return str;\n    },\n    /**\n     * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n     *\n     * @param {Array} arr The array to find an element of.\n     * @param {*} element The element to find in the array, and return the index of.\n     * @return {Number} The index of the `element`, or -1 if it was not found.\n     */\n    indexOf: function (arr, element) {\n      if (Array.prototype.indexOf) {\n        return arr.indexOf(element);\n      } else {\n        for (var i = 0, len = arr.length; i < len; i++) {\n          if (arr[i] === element) return i;\n        }\n        return -1;\n      }\n    },\n    /**\n     * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n     * with a regular expression that contains capturing parenthesis.\n     *\n     * For example:\n     *\n     *     // Modern browsers:\n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n     *\n     *     // Old IE (including IE8):\n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n     *\n     * This method emulates the functionality of modern browsers for the old IE case.\n     *\n     * @param {String} str The string to split.\n     * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n     *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n     *   description of this method.\n     *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n     *   Note #2: for simplicity's sake, the regular expression does not need\n     *   to contain capturing parenthesis - it will be assumed that any match has them.\n     * @return {String[]} The split array of strings, with the splitting character(s) included.\n     */\n    splitAndCapture: function (str, splitRegex) {\n      if (!splitRegex.global) throw new Error(\"`splitRegex` must have the 'g' flag set\");\n      var result = [],\n        lastIdx = 0,\n        match;\n      while (match = splitRegex.exec(str)) {\n        result.push(str.substring(lastIdx, match.index));\n        result.push(match[0]); // push the splitting char(s)\n\n        lastIdx = match.index + match[0].length;\n      }\n      result.push(str.substring(lastIdx));\n      return result;\n    },\n    /**\n     * Trims the leading and trailing whitespace from a string.\n     *\n     * @param {String} str The string to trim.\n     * @return {String}\n     */\n    trim: function (str) {\n      return str.replace(this.trimRegex, '');\n    }\n  };\n  /*global Autolinker */\n  /*jshint boss:true */\n  /**\n   * @class Autolinker.HtmlTag\n   * @extends Object\n   *\n   * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n   *\n   * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n   * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n   *\n   * ## Examples\n   *\n   * Example instantiation:\n   *\n   *     var tag = new Autolinker.HtmlTag( {\n   *         tagName : 'a',\n   *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n   *         innerHtml : 'Google'\n   *     } );\n   *\n   *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n   *\n   *     // Individual accessor methods\n   *     tag.getTagName();                 // 'a'\n   *     tag.getAttr( 'href' );            // 'http://google.com'\n   *     tag.hasClass( 'external-link' );  // true\n   *\n   *\n   * Using mutator methods (which may be used in combination with instantiation config properties):\n   *\n   *     var tag = new Autolinker.HtmlTag();\n   *     tag.setTagName( 'a' );\n   *     tag.setAttr( 'href', 'http://google.com' );\n   *     tag.addClass( 'external-link' );\n   *     tag.setInnerHtml( 'Google' );\n   *\n   *     tag.getTagName();                 // 'a'\n   *     tag.getAttr( 'href' );            // 'http://google.com'\n   *     tag.hasClass( 'external-link' );  // true\n   *\n   *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n   *\n   *\n   * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n   *\n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n   *             tag.setAttr( 'rel', 'nofollow' );\n   *\n   *             return tag;\n   *         }\n   *     } );\n   *\n   *     // generated html:\n   *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n   *\n   *\n   * ## Example use with a new tag for the replacement\n   *\n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = new Autolinker.HtmlTag( {\n   *                 tagName : 'button',\n   *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n   *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n   *             } );\n   *\n   *             return tag;\n   *         }\n   *     } );\n   *\n   *     // generated html:\n   *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n   */\n  Autolinker.HtmlTag = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} tagName\n     *\n     * The tag name. Ex: 'a', 'button', etc.\n     *\n     * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}\n     * is executed.\n     */\n\n    /**\n     * @cfg {Object.<String, String>} attrs\n     *\n     * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n     * values are the attribute values.\n     */\n\n    /**\n     * @cfg {String} innerHtml\n     *\n     * The inner HTML for the tag.\n     *\n     * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym\n     * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n     * if you prefer, but this one is recommended.\n     */\n\n    /**\n     * @cfg {String} innerHTML\n     *\n     * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n     * for acronym names.\n     */\n\n    /**\n     * @protected\n     * @property {RegExp} whitespaceRegex\n     *\n     * Regular expression used to match whitespace in a string of CSS classes.\n     */\n    whitespaceRegex: /\\s+/,\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n     */\n    constructor: function (cfg) {\n      Autolinker.Util.assign(this, cfg);\n      this.innerHtml = this.innerHtml || this.innerHTML; // accept either the camelCased form or the fully capitalized acronym\n    },\n    /**\n     * Sets the tag name that will be used to generate the tag with.\n     *\n     * @param {String} tagName\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setTagName: function (tagName) {\n      this.tagName = tagName;\n      return this;\n    },\n    /**\n     * Retrieves the tag name.\n     *\n     * @return {String}\n     */\n    getTagName: function () {\n      return this.tagName || \"\";\n    },\n    /**\n     * Sets an attribute on the HtmlTag.\n     *\n     * @param {String} attrName The attribute name to set.\n     * @param {String} attrValue The attribute value to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setAttr: function (attrName, attrValue) {\n      var tagAttrs = this.getAttrs();\n      tagAttrs[attrName] = attrValue;\n      return this;\n    },\n    /**\n     * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n     *\n     * @param {String} name The attribute name to retrieve.\n     * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n     */\n    getAttr: function (attrName) {\n      return this.getAttrs()[attrName];\n    },\n    /**\n     * Sets one or more attributes on the HtmlTag.\n     *\n     * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setAttrs: function (attrs) {\n      var tagAttrs = this.getAttrs();\n      Autolinker.Util.assign(tagAttrs, attrs);\n      return this;\n    },\n    /**\n     * Retrieves the attributes Object (map) for the HtmlTag.\n     *\n     * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n     */\n    getAttrs: function () {\n      return this.attrs || (this.attrs = {});\n    },\n    /**\n     * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setClass: function (cssClass) {\n      return this.setAttr('class', cssClass);\n    },\n    /**\n     * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to add.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    addClass: function (cssClass) {\n      var classAttr = this.getClass(),\n        whitespaceRegex = this.whitespaceRegex,\n        indexOf = Autolinker.Util.indexOf,\n        // to support IE8 and below\n        classes = !classAttr ? [] : classAttr.split(whitespaceRegex),\n        newClasses = cssClass.split(whitespaceRegex),\n        newClass;\n      while (newClass = newClasses.shift()) {\n        if (indexOf(classes, newClass) === -1) {\n          classes.push(newClass);\n        }\n      }\n      this.getAttrs()['class'] = classes.join(\" \");\n      return this;\n    },\n    /**\n     * Convenience method to remove one or more CSS classes from the HtmlTag.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to remove.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    removeClass: function (cssClass) {\n      var classAttr = this.getClass(),\n        whitespaceRegex = this.whitespaceRegex,\n        indexOf = Autolinker.Util.indexOf,\n        // to support IE8 and below\n        classes = !classAttr ? [] : classAttr.split(whitespaceRegex),\n        removeClasses = cssClass.split(whitespaceRegex),\n        removeClass;\n      while (classes.length && (removeClass = removeClasses.shift())) {\n        var idx = indexOf(classes, removeClass);\n        if (idx !== -1) {\n          classes.splice(idx, 1);\n        }\n      }\n      this.getAttrs()['class'] = classes.join(\" \");\n      return this;\n    },\n    /**\n     * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n     * there are multiple.\n     *\n     * @return {String}\n     */\n    getClass: function () {\n      return this.getAttrs()['class'] || \"\";\n    },\n    /**\n     * Convenience method to check if the tag has a CSS class or not.\n     *\n     * @param {String} cssClass The CSS class to check for.\n     * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n     */\n    hasClass: function (cssClass) {\n      return (' ' + this.getClass() + ' ').indexOf(' ' + cssClass + ' ') !== -1;\n    },\n    /**\n     * Sets the inner HTML for the tag.\n     *\n     * @param {String} html The inner HTML to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setInnerHtml: function (html) {\n      this.innerHtml = html;\n      return this;\n    },\n    /**\n     * Retrieves the inner HTML for the tag.\n     *\n     * @return {String}\n     */\n    getInnerHtml: function () {\n      return this.innerHtml || \"\";\n    },\n    /**\n     * Override of superclass method used to generate the HTML string for the tag.\n     *\n     * @return {String}\n     */\n    toAnchorString: function () {\n      var tagName = this.getTagName(),\n        attrsStr = this.buildAttrsStr();\n      attrsStr = attrsStr ? ' ' + attrsStr : ''; // prepend a space if there are actually attributes\n\n      return ['<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>'].join(\"\");\n    },\n    /**\n     * Support method for {@link #toAnchorString}, returns the string space-separated key=\"value\" pairs, used to populate\n     * the stringified HtmlTag.\n     *\n     * @protected\n     * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n     */\n    buildAttrsStr: function () {\n      if (!this.attrs) return \"\"; // no `attrs` Object (map) has been set, return empty string\n\n      var attrs = this.getAttrs(),\n        attrsArr = [];\n      for (var prop in attrs) {\n        if (attrs.hasOwnProperty(prop)) {\n          attrsArr.push(prop + '=\"' + attrs[prop] + '\"');\n        }\n      }\n      return attrsArr.join(\" \");\n    }\n  });\n\n  /*global Autolinker */\n  /*jshint sub:true */\n  /**\n   * @protected\n   * @class Autolinker.AnchorTagBuilder\n   * @extends Object\n   *\n   * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n   *\n   * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may\n   * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n   * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n   *\n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n   *             tag.setAttr( 'rel', 'nofollow' );\n   *\n   *             return tag;\n   *         }\n   *     } );\n   *\n   *     // generated html:\n   *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n   */\n  Autolinker.AnchorTagBuilder = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {Boolean} newWindow\n     * @inheritdoc Autolinker#newWindow\n     */\n\n    /**\n     * @cfg {Number} truncate\n     * @inheritdoc Autolinker#truncate\n     */\n\n    /**\n     * @cfg {String} className\n     * @inheritdoc Autolinker#className\n     */\n\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n     */\n    constructor: function (cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n    /**\n     * Generates the actual anchor (&lt;a&gt;) tag to use in place of the\n     * matched text, via its `match` object.\n     *\n     * @param {Autolinker.match.Match} match The Match instance to generate an\n     *   anchor tag from.\n     * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n     */\n    build: function (match) {\n      var tag = new Autolinker.HtmlTag({\n        tagName: 'a',\n        attrs: this.createAttrs(match.getType(), match.getAnchorHref()),\n        innerHtml: this.processAnchorText(match.getAnchorText())\n      });\n      return tag;\n    },\n    /**\n     * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)\n     *   tag being generated.\n     *\n     * @protected\n     * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n     *   match that an anchor tag is being generated for.\n     * @param {String} href The href for the anchor tag.\n     * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n     */\n    createAttrs: function (matchType, anchorHref) {\n      var attrs = {\n        'href': anchorHref // we'll always have the `href` attribute\n      };\n      var cssClass = this.createCssClass(matchType);\n      if (cssClass) {\n        attrs['class'] = cssClass;\n      }\n      if (this.newWindow) {\n        attrs['target'] = \"_blank\";\n      }\n      return attrs;\n    },\n    /**\n     * Creates the CSS class that will be used for a given anchor tag, based on\n     * the `matchType` and the {@link #className} config.\n     *\n     * @private\n     * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n     *   match that an anchor tag is being generated for.\n     * @return {String} The CSS class string for the link. Example return:\n     *   \"myLink myLink-url\". If no {@link #className} was configured, returns\n     *   an empty string.\n     */\n    createCssClass: function (matchType) {\n      var className = this.className;\n      if (!className) return \"\";else return className + \" \" + className + \"-\" + matchType; // ex: \"myLink myLink-url\", \"myLink myLink-email\", \"myLink myLink-phone\", \"myLink myLink-twitter\", or \"myLink myLink-hashtag\"\n    },\n    /**\n     * Processes the `anchorText` by truncating the text according to the\n     * {@link #truncate} config.\n     *\n     * @private\n     * @param {String} anchorText The anchor tag's text (i.e. what will be\n     *   displayed).\n     * @return {String} The processed `anchorText`.\n     */\n    processAnchorText: function (anchorText) {\n      anchorText = this.doTruncate(anchorText);\n      return anchorText;\n    },\n    /**\n     * Performs the truncation of the `anchorText`, if the `anchorText` is\n     * longer than the {@link #truncate} option. Truncates the text to 2\n     * characters fewer than the {@link #truncate} option, and adds \"..\" to the\n     * end.\n     *\n     * @private\n     * @param {String} text The anchor tag's text (i.e. what will be displayed).\n     * @return {String} The truncated anchor text.\n     */\n    doTruncate: function (anchorText) {\n      return Autolinker.Util.ellipsis(anchorText, this.truncate || Number.POSITIVE_INFINITY);\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @private\n   * @class Autolinker.htmlParser.HtmlParser\n   * @extends Object\n   *\n   * An HTML parser implementation which simply walks an HTML string and returns an array of\n   * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n   *\n   * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / \"walking\n   * around\" HTML tags.\n   */\n  Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend(Object, {\n    /**\n     * @private\n     * @property {RegExp} htmlRegex\n     *\n     * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n     * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n     *\n     * Capturing groups:\n     *\n     * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n     * 2. If it is an end tag, this group will have the '/'.\n     * 3. If it is a comment tag, this group will hold the comment text (i.e.\n     *    the text inside the `&lt;!--` and `--&gt;`.\n     * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n     */\n    htmlRegex: function () {\n      var commentTagRegex = /!--([\\s\\S]+?)--/,\n        tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n        attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,\n        // the unicode range accounts for excluding control chars, and the delete char\n        attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/,\n        // double quoted, single quoted, or unquoted attribute values\n        nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?'; // optional '=[value]'\n\n      return new RegExp([\n      // for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n      '(?:', '<(!DOCTYPE)',\n      // *** Capturing Group 1 - If it's a doctype tag\n\n      // Zero or more attributes following the tag name\n      '(?:', '\\\\s+',\n      // one or more whitespace chars before an attribute\n\n      // Either:\n      // A. attr=\"value\", or\n      // B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n      '(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')', ')*', '>', ')', '|',\n      // All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n      '(?:', '<(/)?',\n      // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.\n      // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n      '(?:', commentTagRegex.source,\n      // *** Capturing Group 3 - A Comment Tag's Text\n\n      '|', '(?:',\n      // *** Capturing Group 4 - The tag name\n      '(' + tagNameRegex.source + ')',\n      // Zero or more attributes following the tag name\n      '(?:', '\\\\s+',\n      // one or more whitespace chars before an attribute\n      nameEqualsValueRegex,\n      // attr=\"value\" (with optional =\"value\" part)\n      ')*', '\\\\s*/?',\n      // any trailing spaces and optional '/' before the closing '>'\n\n      ')', ')', '>', ')'].join(\"\"), 'gi');\n    }(),\n    /**\n     * @private\n     * @property {RegExp} htmlCharacterEntitiesRegex\n     *\n     * The regular expression that matches common HTML character entities.\n     *\n     * Ignoring &amp; as it could be part of a query string -- handling it separately.\n     */\n    htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n    /**\n     * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n     * to represent the HTML structure of the input string.\n     *\n     * @param {String} html The HTML to parse.\n     * @return {Autolinker.htmlParser.HtmlNode[]}\n     */\n    parse: function (html) {\n      var htmlRegex = this.htmlRegex,\n        currentResult,\n        lastIndex = 0,\n        textAndEntityNodes,\n        nodes = []; // will be the result of the method\n\n      while ((currentResult = htmlRegex.exec(html)) !== null) {\n        var tagText = currentResult[0],\n          commentText = currentResult[3],\n          // if we've matched a comment\n          tagName = currentResult[1] || currentResult[4],\n          // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n          isClosingTag = !!currentResult[2],\n          inBetweenTagsText = html.substring(lastIndex, currentResult.index);\n\n        // Push TextNodes and EntityNodes for any text found between tags\n        if (inBetweenTagsText) {\n          textAndEntityNodes = this.parseTextAndEntityNodes(inBetweenTagsText);\n          nodes.push.apply(nodes, textAndEntityNodes);\n        }\n\n        // Push the CommentNode or ElementNode\n        if (commentText) {\n          nodes.push(this.createCommentNode(tagText, commentText));\n        } else {\n          nodes.push(this.createElementNode(tagText, tagName, isClosingTag));\n        }\n        lastIndex = currentResult.index + tagText.length;\n      }\n\n      // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n      if (lastIndex < html.length) {\n        var text = html.substring(lastIndex);\n\n        // Push TextNodes and EntityNodes for any text found between tags\n        if (text) {\n          textAndEntityNodes = this.parseTextAndEntityNodes(text);\n          nodes.push.apply(nodes, textAndEntityNodes);\n        }\n      }\n      return nodes;\n    },\n    /**\n     * Parses text and HTML entity nodes from a given string. The input string\n     * should not have any HTML tags (elements) within it.\n     *\n     * @private\n     * @param {String} text The text to parse.\n     * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n     *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n     *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n     */\n    parseTextAndEntityNodes: function (text) {\n      var nodes = [],\n        textAndEntityTokens = Autolinker.Util.splitAndCapture(text, this.htmlCharacterEntitiesRegex); // split at HTML entities, but include the HTML entities in the results array\n\n      // Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n      // For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n      //   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n      for (var i = 0, len = textAndEntityTokens.length; i < len; i += 2) {\n        var textToken = textAndEntityTokens[i],\n          entityToken = textAndEntityTokens[i + 1];\n        if (textToken) nodes.push(this.createTextNode(textToken));\n        if (entityToken) nodes.push(this.createEntityNode(entityToken));\n      }\n      return nodes;\n    },\n    /**\n     * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n     *\n     * @private\n     * @param {String} tagText The full text of the tag (comment) that was\n     *   matched, including its &lt;!-- and --&gt;.\n     * @param {String} comment The full text of the comment that was matched.\n     */\n    createCommentNode: function (tagText, commentText) {\n      return new Autolinker.htmlParser.CommentNode({\n        text: tagText,\n        comment: Autolinker.Util.trim(commentText)\n      });\n    },\n    /**\n     * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n     *\n     * @private\n     * @param {String} tagText The full text of the tag (element) that was\n     *   matched, including its attributes.\n     * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n     *   be passed to this method as \"img\".\n     * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n     *   otherwise.\n     * @return {Autolinker.htmlParser.ElementNode}\n     */\n    createElementNode: function (tagText, tagName, isClosingTag) {\n      return new Autolinker.htmlParser.ElementNode({\n        text: tagText,\n        tagName: tagName.toLowerCase(),\n        closing: isClosingTag\n      });\n    },\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n     *\n     * @private\n     * @param {String} text The text that was matched for the HTML entity (such\n     *   as '&amp;nbsp;').\n     * @return {Autolinker.htmlParser.EntityNode}\n     */\n    createEntityNode: function (text) {\n      return new Autolinker.htmlParser.EntityNode({\n        text: text\n      });\n    },\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n     *\n     * @private\n     * @param {String} text The text that was matched.\n     * @return {Autolinker.htmlParser.TextNode}\n     */\n    createTextNode: function (text) {\n      return new Autolinker.htmlParser.TextNode({\n        text: text\n      });\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @abstract\n   * @class Autolinker.htmlParser.HtmlNode\n   *\n   * Represents an HTML node found in an input string. An HTML node is one of the\n   * following:\n   *\n   * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents\n   *    HTML tags.\n   * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents\n   *    HTML comments.\n   * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text\n   *    outside or within HTML tags.\n   * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents\n   *    one of the known HTML entities that Autolinker looks for. This includes\n   *    common ones such as &amp;quot; and &amp;nbsp;\n   */\n  Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} text (required)\n     *\n     * The original text that was matched for the HtmlNode.\n     *\n     * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},\n     *   this will be the tag's text.\n     * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},\n     *   this will be the comment's text.\n     * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this\n     *   will be the text itself.\n     * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},\n     *   this will be the text of the HTML entity.\n     */\n    text: \"\",\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance,\n     * specified in an Object (map).\n     */\n    constructor: function (cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @abstract\n     * @return {String}\n     */\n    getType: Autolinker.Util.abstractMethod,\n    /**\n     * Retrieves the {@link #text} for the HtmlNode.\n     *\n     * @return {String}\n     */\n    getText: function () {\n      return this.text;\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.htmlParser.CommentNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   *\n   * Represents an HTML comment node that has been parsed by the\n   * {@link Autolinker.htmlParser.HtmlParser}.\n   *\n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n   * details.\n   */\n  Autolinker.htmlParser.CommentNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * @cfg {String} comment (required)\n     *\n     * The text inside the comment tag. This text is stripped of any leading or\n     * trailing whitespace.\n     */\n    comment: '',\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'comment';\n    },\n    /**\n     * Returns the comment inside the comment tag.\n     *\n     * @return {String}\n     */\n    getComment: function () {\n      return this.comment;\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.htmlParser.ElementNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   *\n   * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   *\n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n   * details.\n   */\n  Autolinker.htmlParser.ElementNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * @cfg {String} tagName (required)\n     *\n     * The name of the tag that was matched.\n     */\n    tagName: '',\n    /**\n     * @cfg {Boolean} closing (required)\n     *\n     * `true` if the element (tag) is a closing tag, `false` if its an opening\n     * tag.\n     */\n    closing: false,\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'element';\n    },\n    /**\n     * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,\n     * returns \"img\".\n     *\n     * @return {String}\n     */\n    getTagName: function () {\n      return this.tagName;\n    },\n    /**\n     * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;\n     * returns `false`, while &lt;/div&gt; returns `true`.\n     *\n     * @return {Boolean}\n     */\n    isClosing: function () {\n      return this.closing;\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.htmlParser.EntityNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   *\n   * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}\n   * method.\n   *\n   * Note that this class will only be returned from the HtmlParser for the set of\n   * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n   *\n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n   * details.\n   */\n  Autolinker.htmlParser.EntityNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'entity';\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.htmlParser.TextNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   *\n   * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   *\n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n   * details.\n   */\n  Autolinker.htmlParser.TextNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'text';\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @private\n   * @class Autolinker.matchParser.MatchParser\n   * @extends Object\n   *\n   * Used by Autolinker to parse potential matches, given an input string of text.\n   *\n   * The MatchParser is fed a non-HTML string in order to search for matches.\n   * Autolinker first uses the {@link Autolinker.htmlParser.HtmlParser} to \"walk\n   * around\" HTML tags, and then the text around the HTML tags is passed into the\n   * MatchParser in order to find the actual matches.\n   */\n  Autolinker.matchParser.MatchParser = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {Boolean} urls\n     * @inheritdoc Autolinker#urls\n     */\n    urls: true,\n    /**\n     * @cfg {Boolean} email\n     * @inheritdoc Autolinker#email\n     */\n    email: true,\n    /**\n     * @cfg {Boolean} twitter\n     * @inheritdoc Autolinker#twitter\n     */\n    twitter: true,\n    /**\n     * @cfg {Boolean} phone\n     * @inheritdoc Autolinker#phone\n     */\n    phone: true,\n    /**\n     * @cfg {Boolean/String} hashtag\n     * @inheritdoc Autolinker#hashtag\n     */\n    hashtag: false,\n    /**\n     * @cfg {Boolean} stripPrefix\n     * @inheritdoc Autolinker#stripPrefix\n     */\n    stripPrefix: true,\n    /**\n     * @private\n     * @property {RegExp} matcherRegex\n     *\n     * The regular expression that matches URLs, email addresses, phone #s,\n     * Twitter handles, and Hashtags.\n     *\n     * This regular expression has the following capturing groups:\n     *\n     * 1.  Group that is used to determine if there is a Twitter handle match\n     *     (i.e. \\@someTwitterUser). Simply check for its existence to determine\n     *     if there is a Twitter handle match. The next couple of capturing\n     *     groups give information about the Twitter handle match.\n     * 2.  The whitespace character before the \\@sign in a Twitter handle. This\n     *     is needed because there are no lookbehinds in JS regular expressions,\n     *     and can be used to reconstruct the original string in a replace().\n     * 3.  The Twitter handle itself in a Twitter match. If the match is\n     *     '@someTwitterUser', the handle is 'someTwitterUser'.\n     * 4.  Group that matches an email address. Used to determine if the match\n     *     is an email address, as well as holding the full address. Ex:\n     *     'me@my.com'\n     * 5.  Group that matches a URL in the input text. Ex: 'http://google.com',\n     *     'www.google.com', or just 'google.com'. This also includes a path,\n     *     url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n     * 6.  Group that matches a protocol URL (i.e. 'http://google.com'). This is\n     *     used to match protocol URLs with just a single word, like 'http://localhost',\n     *     where we won't double check that the domain name has at least one '.'\n     *     in it.\n     * 7.  A protocol-relative ('//') match for the case of a 'www.' prefixed\n     *     URL. Will be an empty string if it is not a protocol-relative match.\n     *     We need to know the character before the '//' in order to determine\n     *     if it is a valid match or the // was in a string we don't want to\n     *     auto-link.\n     * 8.  A protocol-relative ('//') match for the case of a known TLD prefixed\n     *     URL. Will be an empty string if it is not a protocol-relative match.\n     *     See #6 for more info.\n     * 9.  Group that is used to determine if there is a phone number match. The\n     *     next 3 groups give segments of the phone number.\n     * 10. Group that is used to determine if there is a Hashtag match\n     *     (i.e. \\#someHashtag). Simply check for its existence to determine if\n     *     there is a Hashtag match. The next couple of capturing groups give\n     *     information about the Hashtag match.\n     * 11. The whitespace character before the #sign in a Hashtag handle. This\n     *     is needed because there are no look-behinds in JS regular\n     *     expressions, and can be used to reconstruct the original string in a\n     *     replace().\n     * 12. The Hashtag itself in a Hashtag match. If the match is\n     *     '#someHashtag', the hashtag is 'someHashtag'.\n     */\n    matcherRegex: function () {\n      var twitterRegex = /(^|[^\\w])@(\\w{1,15})/,\n        // For matching a twitter handle. Ex: @gregory_jacobs\n\n        hashtagRegex = /(^|[^\\w])#(\\w{1,139})/,\n        // For matching a Hashtag. Ex: #games\n\n        emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,\n        // something@ for email addresses (a.k.a. local-part)\n        phoneRegex = /(?:\\+?\\d{1,3}[-\\040.])?\\(?\\d{3}\\)?[-\\040.]?\\d{3}[-\\040.]\\d{4}/,\n        // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.\n        protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]*:(?![A-Za-z][-.+A-Za-z0-9]*:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,\n        // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n        wwwRegex = /(?:www\\.)/,\n        // starting with 'www.'\n        domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,\n        // anything looking at all like a domain, non-unicode domains, not ending in a period\n        tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|press|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,\n        // match our known top level domains (TLDs)\n\n        // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n        // http://blog.codinghorror.com/the-problem-with-urls/\n        urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n      return new RegExp(['(',\n      // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()\n      // *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and\n      // *** Capturing group $3, which matches the actual twitter handle\n      twitterRegex.source, ')', '|', '(',\n      // *** Capturing group $4, which is used to determine an email match\n      emailRegex.source, domainNameRegex.source, tldRegex.source, ')', '|', '(',\n      // *** Capturing group $5, which is used to match a URL\n      '(?:',\n      // parens to cover match for protocol (optional), and domain\n      '(',\n      // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n      protocolRegex.source, domainNameRegex.source, ')', '|', '(?:',\n      // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n      '(.?//)?',\n      // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n      wwwRegex.source, domainNameRegex.source, ')', '|', '(?:',\n      // non-capturing paren for known a TLD url (ex: google.com)\n      '(.?//)?',\n      // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n      domainNameRegex.source, tldRegex.source, ')', ')', '(?:' + urlSuffixRegex.source + ')?',\n      // match for path, query string, and/or hash anchor - optional\n      ')', '|',\n      // this setup does not scale well for open extension :( Need to rethink design of autolinker...\n      // ***  Capturing group $9, which matches a (USA for now) phone number\n      '(', phoneRegex.source, ')', '|', '(',\n      // *** Capturing group $10, which can be used to check for a Hashtag match. Use group $12 for the actual Hashtag though. $11 may be used to reconstruct the original string in a replace()\n      // *** Capturing group $11, which matches the whitespace character before the '#' sign (needed because of no lookbehinds), and\n      // *** Capturing group $12, which matches the actual Hashtag\n      hashtagRegex.source, ')'].join(\"\"), 'gi');\n    }(),\n    /**\n     * @private\n     * @property {RegExp} charBeforeProtocolRelMatchRegex\n     *\n     * The regular expression used to retrieve the character before a\n     * protocol-relative URL match.\n     *\n     * This is used in conjunction with the {@link #matcherRegex}, which needs\n     * to grab the character before a protocol-relative '//' due to the lack of\n     * a negative look-behind in JavaScript regular expressions. The character\n     * before the match is stripped from the URL.\n     */\n    charBeforeProtocolRelMatchRegex: /^(.)?\\/\\//,\n    /**\n     * @private\n     * @property {Autolinker.MatchValidator} matchValidator\n     *\n     * The MatchValidator object, used to filter out any false positives from\n     * the {@link #matcherRegex}. See {@link Autolinker.MatchValidator} for details.\n     */\n\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder\n     * instance, specified in an Object (map).\n     */\n    constructor: function (cfg) {\n      Autolinker.Util.assign(this, cfg);\n      this.matchValidator = new Autolinker.MatchValidator();\n    },\n    /**\n     * Parses the input `text` to search for matches, and calls the `replaceFn`\n     * to allow replacements of the matches. Returns the `text` with matches\n     * replaced.\n     *\n     * @param {String} text The text to search and repace matches in.\n     * @param {Function} replaceFn The iterator function to handle the\n     *   replacements. The function takes a single argument, a {@link Autolinker.match.Match}\n     *   object, and should return the text that should make the replacement.\n     * @param {Object} [contextObj=window] The context object (\"scope\") to run\n     *   the `replaceFn` in.\n     * @return {String}\n     */\n    replace: function (text, replaceFn, contextObj) {\n      var me = this; // for closure\n\n      return text.replace(this.matcherRegex, function (matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {\n        var matchDescObj = me.processCandidateMatch(matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12); // \"match description\" object\n\n        // Return out with no changes for match types that are disabled (url,\n        // email, phone, etc.), or for matches that are invalid (false\n        // positives from the matcherRegex, which can't use look-behinds\n        // since they are unavailable in JS).\n        if (!matchDescObj) {\n          return matchStr;\n        } else {\n          // Generate replacement text for the match from the `replaceFn`\n          var replaceStr = replaceFn.call(contextObj, matchDescObj.match);\n          return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;\n        }\n      });\n    },\n    /**\n     * Processes a candidate match from the {@link #matcherRegex}.\n     *\n     * Not all matches found by the regex are actual URL/Email/Phone/Twitter/Hashtag\n     * matches, as determined by the {@link #matchValidator}. In this case, the\n     * method returns `null`. Otherwise, a valid Object with `prefixStr`,\n     * `match`, and `suffixStr` is returned.\n     *\n     * @private\n     * @param {String} matchStr The full match that was found by the\n     *   {@link #matcherRegex}.\n     * @param {String} twitterMatch The matched text of a Twitter handle, if the\n     *   match is a Twitter match.\n     * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char\n     *   before the @ sign in a Twitter handle match. This is needed because of\n     *   no lookbehinds in JS regexes, and is need to re-include the character\n     *   for the anchor tag replacement.\n     * @param {String} twitterHandle The actual Twitter user (i.e the word after\n     *   the @ sign in a Twitter match).\n     * @param {String} emailAddressMatch The matched email address for an email\n     *   address match.\n     * @param {String} urlMatch The matched URL string for a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative\n     *   match from a 'www' url, with the character that comes before the '//'.\n     * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative\n     *   match from a TLD (top level domain) match, with the character that\n     *   comes before the '//'.\n     * @param {String} phoneMatch The matched text of a phone number\n     * @param {String} hashtagMatch The matched text of a Twitter\n     *   Hashtag, if the match is a Hashtag match.\n     * @param {String} hashtagPrefixWhitespaceChar The whitespace char\n     *   before the # sign in a Hashtag match. This is needed because of no\n     *   lookbehinds in JS regexes, and is need to re-include the character for\n     *   the anchor tag replacement.\n     * @param {String} hashtag The actual Hashtag (i.e the word\n     *   after the # sign in a Hashtag match).\n     *\n     * @return {Object} A \"match description object\". This will be `null` if the\n     *   match was invalid, or if a match type is disabled. Otherwise, this will\n     *   be an Object (map) with the following properties:\n     * @return {String} return.prefixStr The char(s) that should be prepended to\n     *   the replacement string. These are char(s) that were needed to be\n     *   included from the regex match that were ignored by processing code, and\n     *   should be re-inserted into the replacement stream.\n     * @return {String} return.suffixStr The char(s) that should be appended to\n     *   the replacement string. These are char(s) that were needed to be\n     *   included from the regex match that were ignored by processing code, and\n     *   should be re-inserted into the replacement stream.\n     * @return {Autolinker.match.Match} return.match The Match object that\n     *   represents the match that was found.\n     */\n    processCandidateMatch: function (matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch, phoneMatch, hashtagMatch, hashtagPrefixWhitespaceChar, hashtag) {\n      // Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will\n      // be added to `prefixStr` and `suffixStr`).\n\n      var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n        match,\n        // Will be an Autolinker.match.Match object\n\n        prefixStr = \"\",\n        // A string to use to prefix the anchor tag that is created. This is needed for the Twitter and Hashtag matches.\n        suffixStr = \"\"; // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n\n      // Return out with `null` for match types that are disabled (url, email,\n      // twitter, hashtag), or for matches that are invalid (false positives\n      // from the matcherRegex, which can't use look-behinds since they are\n      // unavailable in JS).\n      if (urlMatch && !this.urls || emailAddressMatch && !this.email || phoneMatch && !this.phone || twitterMatch && !this.twitter || hashtagMatch && !this.hashtag || !this.matchValidator.isValidMatch(urlMatch, protocolUrlMatch, protocolRelativeMatch)) {\n        return null;\n      }\n\n      // Handle a closing parenthesis at the end of the match, and exclude it\n      // if there is not a matching open parenthesis\n      // in the match itself.\n      if (this.matchHasUnbalancedClosingParen(matchStr)) {\n        matchStr = matchStr.substr(0, matchStr.length - 1); // remove the trailing \")\"\n        suffixStr = \")\"; // this will be added after the generated <a> tag\n      } else {\n        // Handle an invalid character after the TLD\n        var pos = this.matchHasInvalidCharAfterTld(urlMatch, protocolUrlMatch);\n        if (pos > -1) {\n          suffixStr = matchStr.substr(pos); // this will be added after the generated <a> tag\n          matchStr = matchStr.substr(0, pos); // remove the trailing invalid chars\n        }\n      }\n      if (emailAddressMatch) {\n        match = new Autolinker.match.Email({\n          matchedText: matchStr,\n          email: emailAddressMatch\n        });\n      } else if (twitterMatch) {\n        // fix up the `matchStr` if there was a preceding whitespace char,\n        // which was needed to determine the match itself (since there are\n        // no look-behinds in JS regexes)\n        if (twitterHandlePrefixWhitespaceChar) {\n          prefixStr = twitterHandlePrefixWhitespaceChar;\n          matchStr = matchStr.slice(1); // remove the prefixed whitespace char from the match\n        }\n        match = new Autolinker.match.Twitter({\n          matchedText: matchStr,\n          twitterHandle: twitterHandle\n        });\n      } else if (phoneMatch) {\n        // remove non-numeric values from phone number string\n        var cleanNumber = matchStr.replace(/\\D/g, '');\n        match = new Autolinker.match.Phone({\n          matchedText: matchStr,\n          number: cleanNumber\n        });\n      } else if (hashtagMatch) {\n        // fix up the `matchStr` if there was a preceding whitespace char,\n        // which was needed to determine the match itself (since there are\n        // no look-behinds in JS regexes)\n        if (hashtagPrefixWhitespaceChar) {\n          prefixStr = hashtagPrefixWhitespaceChar;\n          matchStr = matchStr.slice(1); // remove the prefixed whitespace char from the match\n        }\n        match = new Autolinker.match.Hashtag({\n          matchedText: matchStr,\n          serviceName: this.hashtag,\n          hashtag: hashtag\n        });\n      } else {\n        // url match\n        // If it's a protocol-relative '//' match, remove the character\n        // before the '//' (which the matcherRegex needed to match due to\n        // the lack of a negative look-behind in JavaScript regular\n        // expressions)\n        if (protocolRelativeMatch) {\n          var charBeforeMatch = protocolRelativeMatch.match(this.charBeforeProtocolRelMatchRegex)[1] || \"\";\n          if (charBeforeMatch) {\n            // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n            prefixStr = charBeforeMatch;\n            matchStr = matchStr.slice(1); // remove the prefixed char from the match\n          }\n        }\n        match = new Autolinker.match.Url({\n          matchedText: matchStr,\n          url: matchStr,\n          protocolUrlMatch: !!protocolUrlMatch,\n          protocolRelativeMatch: !!protocolRelativeMatch,\n          stripPrefix: this.stripPrefix\n        });\n      }\n      return {\n        prefixStr: prefixStr,\n        suffixStr: suffixStr,\n        match: match\n      };\n    },\n    /**\n     * Determines if a match found has an unmatched closing parenthesis. If so,\n     * this parenthesis will be removed from the match itself, and appended\n     * after the generated anchor tag in {@link #processCandidateMatch}.\n     *\n     * A match may have an extra closing parenthesis at the end of the match\n     * because the regular expression must include parenthesis for URLs such as\n     * \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n     *\n     * However, an extra parenthesis *will* be included when the URL itself is\n     * wrapped in parenthesis, such as in the case of \"(wikipedia.com/something_(disambiguation))\".\n     * In this case, the last closing parenthesis should *not* be part of the\n     * URL itself, and this method will return `true`.\n     *\n     * @private\n     * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n     * @return {Boolean} `true` if there is an unbalanced closing parenthesis at\n     *   the end of the `matchStr`, `false` otherwise.\n     */\n    matchHasUnbalancedClosingParen: function (matchStr) {\n      var lastChar = matchStr.charAt(matchStr.length - 1);\n      if (lastChar === ')') {\n        var openParensMatch = matchStr.match(/\\(/g),\n          closeParensMatch = matchStr.match(/\\)/g),\n          numOpenParens = openParensMatch && openParensMatch.length || 0,\n          numCloseParens = closeParensMatch && closeParensMatch.length || 0;\n        if (numOpenParens < numCloseParens) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Determine if there's an invalid character after the TLD in a URL. Valid\n     * characters after TLD are ':/?#'. Exclude protocol matched URLs from this\n     * check.\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @return {Number} the position where the invalid character was found. If\n     *   no such character was found, returns -1\n     */\n    matchHasInvalidCharAfterTld: function (urlMatch, protocolUrlMatch) {\n      if (!urlMatch) {\n        return -1;\n      }\n      var offset = 0;\n      if (protocolUrlMatch) {\n        offset = urlMatch.indexOf(':');\n        urlMatch = urlMatch.slice(offset);\n      }\n      var re = /^((.?\\/\\/)?[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]\\.[A-Za-z]+)/;\n      var res = re.exec(urlMatch);\n      if (res === null) {\n        return -1;\n      }\n      offset += res[1].length;\n      urlMatch = urlMatch.slice(res[1].length);\n      if (/^[^.A-Za-z:\\/?#]/.test(urlMatch)) {\n        return offset;\n      }\n      return -1;\n    }\n  });\n\n  /*global Autolinker */\n  /*jshint scripturl:true */\n  /**\n   * @private\n   * @class Autolinker.MatchValidator\n   * @extends Object\n   *\n   * Used by Autolinker to filter out false positives from the\n   * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n   *\n   * Due to the limitations of regular expressions (including the missing feature\n   * of look-behinds in JS regular expressions), we cannot always determine the\n   * validity of a given match. This class applies a bit of additional logic to\n   * filter out any false positives that have been matched by the\n   * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n   */\n  Autolinker.MatchValidator = Autolinker.Util.extend(Object, {\n    /**\n     * @private\n     * @property {RegExp} invalidProtocolRelMatchRegex\n     *\n     * The regular expression used to check a potential protocol-relative URL\n     * match, coming from the {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n     * A protocol-relative URL is, for example, \"//yahoo.com\"\n     *\n     * This regular expression checks to see if there is a word character before\n     * the '//' match in order to determine if we should actually autolink a\n     * protocol-relative URL. This is needed because there is no negative\n     * look-behind in JavaScript regular expressions.\n     *\n     * For instance, we want to autolink something like \"Go to: //google.com\",\n     * but we don't want to autolink something like \"abc//google.com\"\n     */\n    invalidProtocolRelMatchRegex: /^[\\w]\\/\\//,\n    /**\n     * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n     *\n     * @private\n     * @property {RegExp} hasFullProtocolRegex\n     */\n    hasFullProtocolRegex: /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//,\n    /**\n     * Regex to find the URI scheme, such as 'mailto:'.\n     *\n     * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n     *\n     * @private\n     * @property {RegExp} uriSchemeRegex\n     */\n    uriSchemeRegex: /^[A-Za-z][-.+A-Za-z0-9]*:/,\n    /**\n     * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n     *\n     * @private\n     * @property {RegExp} hasWordCharAfterProtocolRegex\n     */\n    hasWordCharAfterProtocolRegex: /:[^\\s]*?[A-Za-z]/,\n    /**\n     * Determines if a given match found by the {@link Autolinker.matchParser.MatchParser}\n     * is valid. Will return `false` for:\n     *\n     * 1) URL matches which do not have at least have one period ('.') in the\n     *    domain name (effectively skipping over matches like \"abc:def\").\n     *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n     * 2) URL matches which do not have at least one word character in the\n     *    domain name (effectively skipping over matches like \"git:1.0\").\n     * 3) A protocol-relative url match (a URL beginning with '//') whose\n     *    previous character is a word character (effectively skipping over\n     *    strings like \"abc//google.com\")\n     *\n     * Otherwise, returns `true`.\n     *\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @param {String} protocolRelativeMatch The protocol-relative string for a\n     *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n     *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n     *   invalid if there is a word character preceding the '//'.\n     * @return {Boolean} `true` if the match given is valid and should be\n     *   processed, or `false` if the match is invalid and/or should just not be\n     *   processed.\n     */\n    isValidMatch: function (urlMatch, protocolUrlMatch, protocolRelativeMatch) {\n      if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) ||\n      // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n      this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) ||\n      // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n      this.isInvalidProtocolRelativeMatch(protocolRelativeMatch) // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n      ) {\n        return false;\n      }\n      return true;\n    },\n    /**\n     * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n     * `false` if the scheme is 'javascript:' or 'vbscript:'\n     *\n     * @private\n     * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n     *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n     * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n     */\n    isValidUriScheme: function (uriSchemeMatch) {\n      var uriScheme = uriSchemeMatch.match(this.uriSchemeRegex)[0].toLowerCase();\n      return uriScheme !== 'javascript:' && uriScheme !== 'vbscript:';\n    },\n    /**\n     * Determines if a URL match does not have either:\n     *\n     * a) a full protocol (i.e. 'http://'), or\n     * b) at least one dot ('.') in the domain name (for a non-full-protocol\n     *    match).\n     *\n     * Either situation is considered an invalid URL (ex: 'git:d' does not have\n     * either the '://' part, or at least one dot in the domain name. If the\n     * match was 'git:abc.com', we would consider this valid.)\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @return {Boolean} `true` if the URL match does not have a full protocol,\n     *   or at least one dot ('.') in a non-full-protocol match.\n     */\n    urlMatchDoesNotHaveProtocolOrDot: function (urlMatch, protocolUrlMatch) {\n      return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1;\n    },\n    /**\n     * Determines if a URL match does not have at least one word character after\n     * the protocol (i.e. in the domain name).\n     *\n     * At least one letter character must exist in the domain name after a\n     * protocol match. Ex: skip over something like \"git:1.0\"\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n     *   have a protocol in the URL string, in order to check for a word\n     *   character after the protocol separator (':').\n     * @return {Boolean} `true` if the URL match does not have at least one word\n     *   character in it after the protocol, `false` otherwise.\n     */\n    urlMatchDoesNotHaveAtLeastOneWordChar: function (urlMatch, protocolUrlMatch) {\n      if (urlMatch && protocolUrlMatch) {\n        return !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n      } else {\n        return false;\n      }\n    },\n    /**\n     * Determines if a protocol-relative match is an invalid one. This method\n     * returns `true` if there is a `protocolRelativeMatch`, and that match\n     * contains a word character before the '//' (i.e. it must contain\n     * whitespace or nothing before the '//' in order to be considered valid).\n     *\n     * @private\n     * @param {String} protocolRelativeMatch The protocol-relative string for a\n     *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n     *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n     *   invalid if there is a word character preceding the '//'.\n     * @return {Boolean} `true` if it is an invalid protocol-relative match,\n     *   `false` otherwise.\n     */\n    isInvalidProtocolRelativeMatch: function (protocolRelativeMatch) {\n      return !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test(protocolRelativeMatch);\n    }\n  });\n\n  /*global Autolinker */\n  /**\n   * @abstract\n   * @class Autolinker.match.Match\n   * \n   * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a \n   * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n   * \n   * For example:\n   * \n   *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n   *     \n   *     var linkedText = Autolinker.link( input, {\n   *         replaceFn : function( autolinker, match ) {\n   *             console.log( \"href = \", match.getAnchorHref() );\n   *             console.log( \"text = \", match.getAnchorText() );\n   *         \n   *             switch( match.getType() ) {\n   *                 case 'url' : \n   *                     console.log( \"url: \", match.getUrl() );\n   *                     \n   *                 case 'email' :\n   *                     console.log( \"email: \", match.getEmail() );\n   *                     \n   *                 case 'twitter' :\n   *                     console.log( \"twitter: \", match.getTwitterHandle() );\n   *             }\n   *         }\n   *     } );\n   *     \n   * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n   */\n  Autolinker.match.Match = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} matchedText (required)\n     * \n     * The original text that was matched.\n     */\n\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n     */\n    constructor: function (cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getType: Autolinker.Util.abstractMethod,\n    /**\n     * Returns the original text that was matched.\n     * \n     * @return {String}\n     */\n    getMatchedText: function () {\n      return this.matchedText;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getAnchorHref: Autolinker.Util.abstractMethod,\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getAnchorText: Autolinker.Util.abstractMethod\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.match.Email\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Email match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n  Autolinker.match.Email = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} email (required)\n     * \n     * The email address that was matched.\n     */\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function () {\n      return 'email';\n    },\n    /**\n     * Returns the email address that was matched.\n     * \n     * @return {String}\n     */\n    getEmail: function () {\n      return this.email;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function () {\n      return 'mailto:' + this.email;\n    },\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function () {\n      return this.email;\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.match.Hashtag\n   * @extends Autolinker.match.Match\n   *\n   * Represents a Hashtag match found in an input string which should be\n   * Autolinked.\n   *\n   * See this class's superclass ({@link Autolinker.match.Match}) for more\n   * details.\n   */\n  Autolinker.match.Hashtag = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} serviceName (required)\n     *\n     * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n     * for available values.\n     */\n\n    /**\n     * @cfg {String} hashtag (required)\n     *\n     * The Hashtag that was matched, without the '#'.\n     */\n\n    /**\n     * Returns the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'hashtag';\n    },\n    /**\n     * Returns the matched hashtag.\n     *\n     * @return {String}\n     */\n    getHashtag: function () {\n      return this.hashtag;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorHref: function () {\n      var serviceName = this.serviceName,\n        hashtag = this.hashtag;\n      switch (serviceName) {\n        case 'twitter':\n          return 'https://twitter.com/hashtag/' + hashtag;\n        case 'facebook':\n          return 'https://www.facebook.com/hashtag/' + hashtag;\n        case 'instagram':\n          return 'https://instagram.com/explore/tags/' + hashtag;\n        default:\n          // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n          throw new Error('Unknown service name to point hashtag to: ', serviceName);\n      }\n    },\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorText: function () {\n      return '#' + this.hashtag;\n    }\n  });\n\n  /*global Autolinker */\n  /**\n   * @class Autolinker.match.Phone\n   * @extends Autolinker.match.Match\n   *\n   * Represents a Phone number match found in an input string which should be\n   * Autolinked.\n   *\n   * See this class's superclass ({@link Autolinker.match.Match}) for more\n   * details.\n   */\n  Autolinker.match.Phone = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} number (required)\n     *\n     * The phone number that was matched.\n     */\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    getType: function () {\n      return 'phone';\n    },\n    /**\n     * Returns the phone number that was matched.\n     *\n     * @return {String}\n     */\n    getNumber: function () {\n      return this.number;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorHref: function () {\n      return 'tel:' + this.number;\n    },\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorText: function () {\n      return this.matchedText;\n    }\n  });\n\n  /*global Autolinker */\n  /**\n   * @class Autolinker.match.Twitter\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Twitter match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n  Autolinker.match.Twitter = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} twitterHandle (required)\n     * \n     * The Twitter handle that was matched.\n     */\n\n    /**\n     * Returns the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function () {\n      return 'twitter';\n    },\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getTwitterHandle: function () {\n      return this.twitterHandle;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function () {\n      return 'https://twitter.com/' + this.twitterHandle;\n    },\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function () {\n      return '@' + this.twitterHandle;\n    }\n  });\n  /*global Autolinker */\n  /**\n   * @class Autolinker.match.Url\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Url match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n  Autolinker.match.Url = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} url (required)\n     * \n     * The url that was matched.\n     */\n\n    /**\n     * @cfg {Boolean} protocolUrlMatch (required)\n     * \n     * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or\n     * known TLD match.\n     */\n\n    /**\n     * @cfg {Boolean} protocolRelativeMatch (required)\n     * \n     * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n     * and will be either http:// or https:// based on the protocol that the site is loaded under.\n     */\n\n    /**\n     * @cfg {Boolean} stripPrefix (required)\n     * @inheritdoc Autolinker#stripPrefix\n     */\n\n    /**\n     * @private\n     * @property {RegExp} urlPrefixRegex\n     * \n     * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.\n     */\n    urlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n    /**\n     * @private\n     * @property {RegExp} protocolRelativeRegex\n     * \n     * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n     * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n     */\n    protocolRelativeRegex: /^\\/\\//,\n    /**\n     * @private\n     * @property {Boolean} protocolPrepended\n     * \n     * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n     * {@link #url} did not have a protocol)\n     */\n    protocolPrepended: false,\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function () {\n      return 'url';\n    },\n    /**\n     * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n     * match was missing a protocol.\n     * \n     * @return {String}\n     */\n    getUrl: function () {\n      var url = this.url;\n\n      // if the url string doesn't begin with a protocol, assume 'http://'\n      if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {\n        url = this.url = 'http://' + url;\n        this.protocolPrepended = true;\n      }\n      return url;\n    },\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function () {\n      var url = this.getUrl();\n      return url.replace(/&amp;/g, '&'); // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html \n    },\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function () {\n      var anchorText = this.getUrl();\n      if (this.protocolRelativeMatch) {\n        // Strip off any protocol-relative '//' from the anchor text\n        anchorText = this.stripProtocolRelativePrefix(anchorText);\n      }\n      if (this.stripPrefix) {\n        anchorText = this.stripUrlPrefix(anchorText);\n      }\n      anchorText = this.removeTrailingSlash(anchorText); // remove trailing slash, if there is one\n\n      return anchorText;\n    },\n    // ---------------------------------------\n\n    // Utility Functionality\n\n    /**\n     * Strips the URL prefix (such as \"http://\" or \"https://\") from the given text.\n     * \n     * @private\n     * @param {String} text The text of the anchor that is being generated, for which to strip off the\n     *   url prefix (such as stripping off \"http://\")\n     * @return {String} The `anchorText`, with the prefix stripped.\n     */\n    stripUrlPrefix: function (text) {\n      return text.replace(this.urlPrefixRegex, '');\n    },\n    /**\n     * Strips any protocol-relative '//' from the anchor text.\n     * \n     * @private\n     * @param {String} text The text of the anchor that is being generated, for which to strip off the\n     *   protocol-relative prefix (such as stripping off \"//\")\n     * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n     */\n    stripProtocolRelativePrefix: function (text) {\n      return text.replace(this.protocolRelativeRegex, '');\n    },\n    /**\n     * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n     * \n     * @private\n     * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n     *   slash ('/') that may exist.\n     * @return {String} The `anchorText`, with the trailing slash removed.\n     */\n    removeTrailingSlash: function (anchorText) {\n      if (anchorText.charAt(anchorText.length - 1) === '/') {\n        anchorText = anchorText.slice(0, -1);\n      }\n      return anchorText;\n    }\n  });\n  return Autolinker;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","Autolinker","cfg","Util","assign","hashtag","Error","prototype","constructor","urls","email","twitter","phone","newWindow","stripPrefix","truncate","undefined","className","htmlParser","matchParser","tagBuilder","link","textOrHtml","getHtmlParser","htmlNodes","parse","anchorTagStackCount","resultHtml","i","len","length","node","nodeType","getType","nodeText","getText","getTagName","isClosing","Math","max","push","linkifiedStr","linkifyStr","join","str","getMatchParser","replace","createMatchReturnVal","match","replaceFnResult","replaceFn","call","getMatchedText","HtmlTag","toAnchorString","getTagBuilder","anchorTag","build","HtmlParser","MatchParser","AnchorTagBuilder","options","autolinker","abstractMethod","trimRegex","dest","src","prop","hasOwnProperty","extend","superclass","protoProps","superclassProto","F","subclass","apply","arguments","subclassProto","ellipsis","truncateLen","ellipsisChars","substring","indexOf","arr","element","Array","splitAndCapture","splitRegex","global","result","lastIdx","exec","index","trim","Object","whitespaceRegex","innerHtml","innerHTML","setTagName","tagName","setAttr","attrName","attrValue","tagAttrs","getAttrs","getAttr","setAttrs","attrs","setClass","cssClass","addClass","classAttr","getClass","classes","split","newClasses","newClass","shift","removeClass","removeClasses","idx","splice","hasClass","setInnerHtml","html","getInnerHtml","attrsStr","buildAttrsStr","attrsArr","tag","createAttrs","getAnchorHref","processAnchorText","getAnchorText","matchType","anchorHref","createCssClass","anchorText","doTruncate","Number","POSITIVE_INFINITY","htmlRegex","commentTagRegex","tagNameRegex","attrNameRegex","attrValueRegex","nameEqualsValueRegex","source","RegExp","htmlCharacterEntitiesRegex","currentResult","lastIndex","textAndEntityNodes","nodes","tagText","commentText","isClosingTag","inBetweenTagsText","parseTextAndEntityNodes","createCommentNode","createElementNode","text","textAndEntityTokens","textToken","entityToken","createTextNode","createEntityNode","CommentNode","comment","ElementNode","toLowerCase","closing","EntityNode","TextNode","HtmlNode","getComment","matcherRegex","twitterRegex","hashtagRegex","emailRegex","phoneRegex","protocolRegex","wwwRegex","domainNameRegex","tldRegex","urlSuffixRegex","charBeforeProtocolRelMatchRegex","matchValidator","MatchValidator","contextObj","me","matchStr","$1","$2","$3","$4","$5","$6","$7","$8","$9","$10","$11","$12","matchDescObj","processCandidateMatch","replaceStr","prefixStr","suffixStr","twitterMatch","twitterHandlePrefixWhitespaceChar","twitterHandle","emailAddressMatch","urlMatch","protocolUrlMatch","wwwProtocolRelativeMatch","tldProtocolRelativeMatch","phoneMatch","hashtagMatch","hashtagPrefixWhitespaceChar","protocolRelativeMatch","isValidMatch","matchHasUnbalancedClosingParen","substr","pos","matchHasInvalidCharAfterTld","Email","matchedText","slice","Twitter","cleanNumber","Phone","number","Hashtag","serviceName","charBeforeMatch","Url","url","lastChar","charAt","openParensMatch","closeParensMatch","numOpenParens","numCloseParens","offset","re","res","test","invalidProtocolRelMatchRegex","hasFullProtocolRegex","uriSchemeRegex","hasWordCharAfterProtocolRegex","isValidUriScheme","urlMatchDoesNotHaveProtocolOrDot","urlMatchDoesNotHaveAtLeastOneWordChar","isInvalidProtocolRelativeMatch","uriSchemeMatch","uriScheme","Match","getEmail","getHashtag","getNumber","getTwitterHandle","urlPrefixRegex","protocolRelativeRegex","protocolPrepended","getUrl","stripProtocolRelativePrefix","stripUrlPrefix","removeTrailingSlash"],"sources":["D:/Growth/Samples/chatbot/node_modules/autolinker/dist/Autolinker.js"],"sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (root['Autolinker'] = factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Autolinker'] = factory();\n  }\n}(this, function () {\n\n/*!\n * Autolinker.js\n * 0.19.1\n *\n * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n * MIT\n *\n * https://github.com/gregjacobs/Autolinker.js\n */\n/**\n * @class Autolinker\n * @extends Object\n *\n * Utility class used to process a given string of text, and wrap the matches in\n * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n *\n * Any of the configuration options may be provided in an Object (map) provided\n * to the Autolinker constructor, which will configure how the {@link #link link()}\n * method will process the links.\n *\n * For example:\n *\n *     var autolinker = new Autolinker( {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *\n *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n *\n *\n * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n * be more convenient for one-off uses. For example:\n *\n *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n *\n *\n * ## Custom Replacements of Links\n *\n * If the configuration options do not provide enough flexibility, a {@link #replaceFn}\n * may be provided to fully customize the output of Autolinker. This function is\n * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is\n * encountered.\n *\n * For example:\n *\n *     var input = \"...\";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags\n *\n *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *\n *             switch( match.getType() ) {\n *                 case 'url' :\n *                     console.log( \"url: \", match.getUrl() );\n *\n *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n *                         tag.setAttr( 'rel', 'nofollow' );\n *                         tag.addClass( 'external-link' );\n *\n *                         return tag;\n *\n *                     } else {\n *                         return true;  // let Autolinker perform its normal anchor tag replacement\n *                     }\n *\n *                 case 'email' :\n *                     var email = match.getEmail();\n *                     console.log( \"email: \", email );\n *\n *                     if( email === \"my@own.address\" ) {\n *                         return false;  // don't auto-link this particular email address; leave as-is\n *                     } else {\n *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n *                     }\n *\n *                 case 'phone' :\n *                     var phoneNumber = match.getPhoneNumber();\n *                     console.log( phoneNumber );\n *\n *                     return '<a href=\"http://newplace.to.link.phone.numbers.to/\">' + phoneNumber + '</a>';\n *\n *                 case 'twitter' :\n *                     var twitterHandle = match.getTwitterHandle();\n *                     console.log( twitterHandle );\n *\n *                     return '<a href=\"http://newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n *\n *                 case 'hashtag' :\n *                     var hashtag = match.getHashtag();\n *                     console.log( hashtag );\n *\n *                     return '<a href=\"http://newplace.to.link.hashtag.handles.to/\">' + hashtag + '</a>';\n *             }\n *         }\n *     } );\n *\n *\n * The function may return the following values:\n *\n * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n *   the match.\n * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n *\n * @constructor\n * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n */\nvar Autolinker = function( cfg ) {\n\tAutolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n\n\t// Validate the value of the `hashtag` cfg.\n\tvar hashtag = this.hashtag;\n\tif( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram' ) {\n\t\tthrow new Error( \"invalid `hashtag` cfg - see docs\" );\n\t}\n};\n\nAutolinker.prototype = {\n\tconstructor : Autolinker,  // fix constructor property\n\n\t/**\n\t * @cfg {Boolean} urls\n\t *\n\t * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n\t */\n\turls : true,\n\n\t/**\n\t * @cfg {Boolean} email\n\t *\n\t * `true` if email addresses should be automatically linked, `false` if they should not be.\n\t */\n\temail : true,\n\n\t/**\n\t * @cfg {Boolean} twitter\n\t *\n\t * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n\t */\n\ttwitter : true,\n\n\t/**\n\t * @cfg {Boolean} phone\n\t *\n\t * `true` if Phone numbers (\"(555)555-5555\") should be automatically linked, `false` if they should not be.\n\t */\n\tphone: true,\n\n\t/**\n\t * @cfg {Boolean/String} hashtag\n\t *\n\t * A string for the service name to have hashtags (ex: \"#myHashtag\")\n\t * auto-linked to. The currently-supported values are:\n\t *\n\t * - 'twitter'\n\t * - 'facebook'\n\t * - 'instagram'\n\t *\n\t * Pass `false` to skip auto-linking of hashtags.\n\t */\n\thashtag : false,\n\n\t/**\n\t * @cfg {Boolean} newWindow\n\t *\n\t * `true` if the links should open in a new window, `false` otherwise.\n\t */\n\tnewWindow : true,\n\n\t/**\n\t * @cfg {Boolean} stripPrefix\n\t *\n\t * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped\n\t * from the beginning of URL links' text, `false` otherwise.\n\t */\n\tstripPrefix : true,\n\n\t/**\n\t * @cfg {Number} truncate\n\t *\n\t * A number for how many characters long matched text should be truncated to inside the text of\n\t * a link. If the matched text is over this number of characters, it will be truncated to this length by\n\t * adding a two period ellipsis ('..') to the end of the string.\n\t *\n\t * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n\t * something like this: 'yahoo.com/some/long/pat..'\n\t */\n\ttruncate : undefined,\n\n\t/**\n\t * @cfg {String} className\n\t *\n\t * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n\t * plus match suffixes for styling url/email/phone/twitter/hashtag links differently.\n\t *\n\t * For example, if this config is provided as \"myLink\", then:\n\t *\n\t * - URL links will have the CSS classes: \"myLink myLink-url\"\n\t * - Email links will have the CSS classes: \"myLink myLink-email\", and\n\t * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n\t * - Phone links will have the CSS classes: \"myLink myLink-phone\"\n\t * - Hashtag links will have the CSS classes: \"myLink myLink-hashtag\"\n\t */\n\tclassName : \"\",\n\n\t/**\n\t * @cfg {Function} replaceFn\n\t *\n\t * A function to individually process each match found in the input string.\n\t *\n\t * See the class's description for usage.\n\t *\n\t * This function is called with the following parameters:\n\t *\n\t * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n\t *   as the instance's {@link #getTagBuilder tag builder}).\n\t * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n\t *   match that the `replaceFn` is currently processing. See {@link Autolinker.match.Match} subclasses for details.\n\t */\n\n\n\t/**\n\t * @private\n\t * @property {Autolinker.htmlParser.HtmlParser} htmlParser\n\t *\n\t * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n\t * in the {@link #getHtmlParser} method.\n\t */\n\thtmlParser : undefined,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.matchParser.MatchParser} matchParser\n\t *\n\t * The MatchParser instance used to find matches in the text nodes of an input string passed to\n\t * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.\n\t */\n\tmatchParser : undefined,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.AnchorTagBuilder} tagBuilder\n\t *\n\t * The AnchorTagBuilder instance used to build match replacement anchor tags. Note: this is lazily instantiated\n\t * in the {@link #getTagBuilder} method.\n\t */\n\ttagBuilder : undefined,\n\n\t/**\n\t * Automatically links URLs, Email addresses, Phone numbers, Twitter\n\t * handles, and Hashtags found in the given chunk of HTML. Does not link\n\t * URLs found within HTML tags.\n\t *\n\t * For instance, if given the text: `You should go to http://www.yahoo.com`,\n\t * then the result will be `You should go to\n\t * &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n\t *\n\t * This method finds the text around any HTML elements in the input\n\t * `textOrHtml`, which will be the text that is processed. Any original HTML\n\t * elements will be left as-is, as well as the text that is already wrapped\n\t * in anchor (&lt;a&gt;) tags.\n\t *\n\t * @param {String} textOrHtml The HTML or text to autolink matches within\n\t *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n\t *   {@link #twitter}, and {@link #hashtag} options are enabled).\n\t * @return {String} The HTML, with matches automatically linked.\n\t */\n\tlink : function( textOrHtml ) {\n\t\tif( !textOrHtml ) { return \"\"; }  // handle `null` and `undefined`\n\n\t\tvar htmlParser = this.getHtmlParser(),\n\t\t    htmlNodes = htmlParser.parse( textOrHtml ),\n\t\t    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have\n\t\t    resultHtml = [];\n\n\t\tfor( var i = 0, len = htmlNodes.length; i < len; i++ ) {\n\t\t\tvar node = htmlNodes[ i ],\n\t\t\t    nodeType = node.getType(),\n\t\t\t    nodeText = node.getText();\n\n\t\t\tif( nodeType === 'element' ) {\n\t\t\t\t// Process HTML nodes in the input `textOrHtml`\n\t\t\t\tif( node.getTagName() === 'a' ) {\n\t\t\t\t\tif( !node.isClosing() ) {  // it's the start <a> tag\n\t\t\t\t\t\tanchorTagStackCount++;\n\t\t\t\t\t} else {   // it's the end </a> tag\n\t\t\t\t\t\tanchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresultHtml.push( nodeText );  // now add the text of the tag itself verbatim\n\n\t\t\t} else if( nodeType === 'entity' || nodeType === 'comment' ) {\n\t\t\t\tresultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') or HTML comments (such as '<!-- Comment -->') verbatim\n\n\t\t\t} else {\n\t\t\t\t// Process text nodes in the input `textOrHtml`\n\t\t\t\tif( anchorTagStackCount === 0 ) {\n\t\t\t\t\t// If we're not within an <a> tag, process the text node to linkify\n\t\t\t\t\tvar linkifiedStr = this.linkifyStr( nodeText );\n\t\t\t\t\tresultHtml.push( linkifiedStr );\n\n\t\t\t\t} else {\n\t\t\t\t\t// `text` is within an <a> tag, simply append the text - we do not want to autolink anything\n\t\t\t\t\t// already within an <a>...</a> tag\n\t\t\t\t\tresultHtml.push( nodeText );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resultHtml.join( \"\" );\n\t},\n\n\t/**\n\t * Process the text that lies in between HTML tags, performing the anchor\n\t * tag replacements for the matches, and returns the string with the\n\t * replacements made.\n\t *\n\t * This method does the actual wrapping of matches with anchor tags.\n\t *\n\t * @private\n\t * @param {String} str The string of text to auto-link.\n\t * @return {String} The text with anchor tags auto-filled.\n\t */\n\tlinkifyStr : function( str ) {\n\t\treturn this.getMatchParser().replace( str, this.createMatchReturnVal, this );\n\t},\n\n\n\t/**\n\t * Creates the return string value for a given match in the input string,\n\t * for the {@link #linkifyStr} method.\n\t *\n\t * This method handles the {@link #replaceFn}, if one was provided.\n\t *\n\t * @private\n\t * @param {Autolinker.match.Match} match The Match object that represents the match.\n\t * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n\t *   may be the `matchStr` itself if the match is not to be replaced.\n\t */\n\tcreateMatchReturnVal : function( match ) {\n\t\t// Handle a custom `replaceFn` being provided\n\t\tvar replaceFnResult;\n\t\tif( this.replaceFn ) {\n\t\t\treplaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg\n\t\t}\n\n\t\tif( typeof replaceFnResult === 'string' ) {\n\t\t\treturn replaceFnResult;  // `replaceFn` returned a string, use that\n\n\t\t} else if( replaceFnResult === false ) {\n\t\t\treturn match.getMatchedText();  // no replacement for the match\n\n\t\t} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {\n\t\t\treturn replaceFnResult.toAnchorString();\n\n\t\t} else {  // replaceFnResult === true, or no/unknown return value from function\n\t\t\t// Perform Autolinker's default anchor tag generation\n\t\t\tvar tagBuilder = this.getTagBuilder(),\n\t\t\t    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance\n\n\t\t\treturn anchorTag.toAnchorString();\n\t\t}\n\t},\n\n\n\t/**\n\t * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n\t *\n\t * @protected\n\t * @return {Autolinker.htmlParser.HtmlParser}\n\t */\n\tgetHtmlParser : function() {\n\t\tvar htmlParser = this.htmlParser;\n\n\t\tif( !htmlParser ) {\n\t\t\thtmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();\n\t\t}\n\n\t\treturn htmlParser;\n\t},\n\n\n\t/**\n\t * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.\n\t *\n\t * @protected\n\t * @return {Autolinker.matchParser.MatchParser}\n\t */\n\tgetMatchParser : function() {\n\t\tvar matchParser = this.matchParser;\n\n\t\tif( !matchParser ) {\n\t\t\tmatchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {\n\t\t\t\turls        : this.urls,\n\t\t\t\temail       : this.email,\n\t\t\t\ttwitter     : this.twitter,\n\t\t\t\tphone       : this.phone,\n\t\t\t\thashtag     : this.hashtag,\n\t\t\t\tstripPrefix : this.stripPrefix\n\t\t\t} );\n\t\t}\n\n\t\treturn matchParser;\n\t},\n\n\n\t/**\n\t * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n\t * if it does not yet exist.\n\t *\n\t * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n\t * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n\t *\n\t *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n\t *             tag.setAttr( 'rel', 'nofollow' );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n\t *\n\t *     // generated html:\n\t *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n\t *\n\t * @return {Autolinker.AnchorTagBuilder}\n\t */\n\tgetTagBuilder : function() {\n\t\tvar tagBuilder = this.tagBuilder;\n\n\t\tif( !tagBuilder ) {\n\t\t\ttagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {\n\t\t\t\tnewWindow   : this.newWindow,\n\t\t\t\ttruncate    : this.truncate,\n\t\t\t\tclassName   : this.className\n\t\t\t} );\n\t\t}\n\n\t\treturn tagBuilder;\n\t}\n\n};\n\n\n/**\n * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,\n * and Hashtags found in the given chunk of HTML. Does not link URLs found\n * within HTML tags.\n *\n * For instance, if given the text: `You should go to http://www.yahoo.com`,\n * then the result will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n *\n * Example:\n *\n *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n *\n * @static\n * @param {String} textOrHtml The HTML or text to find matches within (depending\n *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},\n *   and {@link #hashtag} options are enabled).\n * @param {Object} [options] Any of the configuration options for the Autolinker\n *   class, specified in an Object (map). See the class description for an\n *   example call.\n * @return {String} The HTML text, with matches automatically linked.\n */\nAutolinker.link = function( textOrHtml, options ) {\n\tvar autolinker = new Autolinker( options );\n\treturn autolinker.link( textOrHtml );\n};\n\n\n// Autolinker Namespaces\nAutolinker.match = {};\nAutolinker.htmlParser = {};\nAutolinker.matchParser = {};\n\n/*global Autolinker */\n/*jshint eqnull:true, boss:true */\n/**\n * @class Autolinker.Util\n * @singleton\n *\n * A few utility methods for Autolinker.\n */\nAutolinker.Util = {\n\n\t/**\n\t * @property {Function} abstractMethod\n\t *\n\t * A function object which represents an abstract method.\n\t */\n\tabstractMethod : function() { throw \"abstract\"; },\n\n\n\t/**\n\t * @private\n\t * @property {RegExp} trimRegex\n\t *\n\t * The regular expression used to trim the leading and trailing whitespace\n\t * from a string.\n\t */\n\ttrimRegex : /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\n\t/**\n\t * Assigns (shallow copies) the properties of `src` onto `dest`.\n\t *\n\t * @param {Object} dest The destination object.\n\t * @param {Object} src The source object.\n\t * @return {Object} The destination object (`dest`)\n\t */\n\tassign : function( dest, src ) {\n\t\tfor( var prop in src ) {\n\t\t\tif( src.hasOwnProperty( prop ) ) {\n\t\t\t\tdest[ prop ] = src[ prop ];\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t},\n\n\n\t/**\n\t * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n\t *\n\t * @param {Function} superclass The constructor function for the superclass.\n\t * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n\t *   special property `constructor`, which will be used as the new subclass's constructor function.\n\t * @return {Function} The new subclass function.\n\t */\n\textend : function( superclass, protoProps ) {\n\t\tvar superclassProto = superclass.prototype;\n\n\t\tvar F = function() {};\n\t\tF.prototype = superclassProto;\n\n\t\tvar subclass;\n\t\tif( protoProps.hasOwnProperty( 'constructor' ) ) {\n\t\t\tsubclass = protoProps.constructor;\n\t\t} else {\n\t\t\tsubclass = function() { superclassProto.constructor.apply( this, arguments ); };\n\t\t}\n\n\t\tvar subclassProto = subclass.prototype = new F();  // set up prototype chain\n\t\tsubclassProto.constructor = subclass;  // fix constructor property\n\t\tsubclassProto.superclass = superclassProto;\n\n\t\tdelete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n\t\tAutolinker.Util.assign( subclassProto, protoProps );\n\n\t\treturn subclass;\n\t},\n\n\n\t/**\n\t * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n\t * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n\t * `len`, the string will be returned unchanged.\n\t *\n\t * @param {String} str The string to truncate and add an ellipsis to.\n\t * @param {Number} truncateLen The length to truncate the string at.\n\t * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n\t *   when truncated. Defaults to '..'\n\t */\n\tellipsis : function( str, truncateLen, ellipsisChars ) {\n\t\tif( str.length > truncateLen ) {\n\t\t\tellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;\n\t\t\tstr = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;\n\t\t}\n\t\treturn str;\n\t},\n\n\n\t/**\n\t * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n\t *\n\t * @param {Array} arr The array to find an element of.\n\t * @param {*} element The element to find in the array, and return the index of.\n\t * @return {Number} The index of the `element`, or -1 if it was not found.\n\t */\n\tindexOf : function( arr, element ) {\n\t\tif( Array.prototype.indexOf ) {\n\t\t\treturn arr.indexOf( element );\n\n\t\t} else {\n\t\t\tfor( var i = 0, len = arr.length; i < len; i++ ) {\n\t\t\t\tif( arr[ i ] === element ) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t},\n\n\n\n\t/**\n\t * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n\t * with a regular expression that contains capturing parenthesis.\n\t *\n\t * For example:\n\t *\n\t *     // Modern browsers:\n\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n\t *\n\t *     // Old IE (including IE8):\n\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n\t *\n\t * This method emulates the functionality of modern browsers for the old IE case.\n\t *\n\t * @param {String} str The string to split.\n\t * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n\t *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n\t *   description of this method.\n\t *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n\t *   Note #2: for simplicity's sake, the regular expression does not need\n\t *   to contain capturing parenthesis - it will be assumed that any match has them.\n\t * @return {String[]} The split array of strings, with the splitting character(s) included.\n\t */\n\tsplitAndCapture : function( str, splitRegex ) {\n\t\tif( !splitRegex.global ) throw new Error( \"`splitRegex` must have the 'g' flag set\" );\n\n\t\tvar result = [],\n\t\t    lastIdx = 0,\n\t\t    match;\n\n\t\twhile( match = splitRegex.exec( str ) ) {\n\t\t\tresult.push( str.substring( lastIdx, match.index ) );\n\t\t\tresult.push( match[ 0 ] );  // push the splitting char(s)\n\n\t\t\tlastIdx = match.index + match[ 0 ].length;\n\t\t}\n\t\tresult.push( str.substring( lastIdx ) );\n\n\t\treturn result;\n\t},\n\n\n\t/**\n\t * Trims the leading and trailing whitespace from a string.\n\t *\n\t * @param {String} str The string to trim.\n\t * @return {String}\n\t */\n\ttrim : function( str ) {\n\t\treturn str.replace( this.trimRegex, '' );\n\t}\n\n};\n/*global Autolinker */\n/*jshint boss:true */\n/**\n * @class Autolinker.HtmlTag\n * @extends Object\n *\n * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n *\n * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n *\n * ## Examples\n *\n * Example instantiation:\n *\n *     var tag = new Autolinker.HtmlTag( {\n *         tagName : 'a',\n *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n *         innerHtml : 'Google'\n *     } );\n *\n *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n *\n *     // Individual accessor methods\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http://google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *\n * Using mutator methods (which may be used in combination with instantiation config properties):\n *\n *     var tag = new Autolinker.HtmlTag();\n *     tag.setTagName( 'a' );\n *     tag.setAttr( 'href', 'http://google.com' );\n *     tag.addClass( 'external-link' );\n *     tag.setInnerHtml( 'Google' );\n *\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http://google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n *\n *\n * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n *\n *\n * ## Example use with a new tag for the replacement\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = new Autolinker.HtmlTag( {\n *                 tagName : 'button',\n *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n *             } );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n */\nAutolinker.HtmlTag = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {String} tagName\n\t *\n\t * The tag name. Ex: 'a', 'button', etc.\n\t *\n\t * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}\n\t * is executed.\n\t */\n\n\t/**\n\t * @cfg {Object.<String, String>} attrs\n\t *\n\t * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n\t * values are the attribute values.\n\t */\n\n\t/**\n\t * @cfg {String} innerHtml\n\t *\n\t * The inner HTML for the tag.\n\t *\n\t * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym\n\t * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n\t * if you prefer, but this one is recommended.\n\t */\n\n\t/**\n\t * @cfg {String} innerHTML\n\t *\n\t * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n\t * for acronym names.\n\t */\n\n\n\t/**\n\t * @protected\n\t * @property {RegExp} whitespaceRegex\n\t *\n\t * Regular expression used to match whitespace in a string of CSS classes.\n\t */\n\twhitespaceRegex : /\\s+/,\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\n\t\tthis.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym\n\t},\n\n\n\t/**\n\t * Sets the tag name that will be used to generate the tag with.\n\t *\n\t * @param {String} tagName\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetTagName : function( tagName ) {\n\t\tthis.tagName = tagName;\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the tag name.\n\t *\n\t * @return {String}\n\t */\n\tgetTagName : function() {\n\t\treturn this.tagName || \"\";\n\t},\n\n\n\t/**\n\t * Sets an attribute on the HtmlTag.\n\t *\n\t * @param {String} attrName The attribute name to set.\n\t * @param {String} attrValue The attribute value to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetAttr : function( attrName, attrValue ) {\n\t\tvar tagAttrs = this.getAttrs();\n\t\ttagAttrs[ attrName ] = attrValue;\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n\t *\n\t * @param {String} name The attribute name to retrieve.\n\t * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n\t */\n\tgetAttr : function( attrName ) {\n\t\treturn this.getAttrs()[ attrName ];\n\t},\n\n\n\t/**\n\t * Sets one or more attributes on the HtmlTag.\n\t *\n\t * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetAttrs : function( attrs ) {\n\t\tvar tagAttrs = this.getAttrs();\n\t\tAutolinker.Util.assign( tagAttrs, attrs );\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the attributes Object (map) for the HtmlTag.\n\t *\n\t * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n\t */\n\tgetAttrs : function() {\n\t\treturn this.attrs || ( this.attrs = {} );\n\t},\n\n\n\t/**\n\t * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetClass : function( cssClass ) {\n\t\treturn this.setAttr( 'class', cssClass );\n\t},\n\n\n\t/**\n\t * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to add.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\taddClass : function( cssClass ) {\n\t\tvar classAttr = this.getClass(),\n\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t    newClasses = cssClass.split( whitespaceRegex ),\n\t\t    newClass;\n\n\t\twhile( newClass = newClasses.shift() ) {\n\t\t\tif( indexOf( classes, newClass ) === -1 ) {\n\t\t\t\tclasses.push( newClass );\n\t\t\t}\n\t\t}\n\n\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convenience method to remove one or more CSS classes from the HtmlTag.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to remove.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tremoveClass : function( cssClass ) {\n\t\tvar classAttr = this.getClass(),\n\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t    removeClasses = cssClass.split( whitespaceRegex ),\n\t\t    removeClass;\n\n\t\twhile( classes.length && ( removeClass = removeClasses.shift() ) ) {\n\t\t\tvar idx = indexOf( classes, removeClass );\n\t\t\tif( idx !== -1 ) {\n\t\t\t\tclasses.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\n\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n\t * there are multiple.\n\t *\n\t * @return {String}\n\t */\n\tgetClass : function() {\n\t\treturn this.getAttrs()[ 'class' ] || \"\";\n\t},\n\n\n\t/**\n\t * Convenience method to check if the tag has a CSS class or not.\n\t *\n\t * @param {String} cssClass The CSS class to check for.\n\t * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n\t */\n\thasClass : function( cssClass ) {\n\t\treturn ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;\n\t},\n\n\n\t/**\n\t * Sets the inner HTML for the tag.\n\t *\n\t * @param {String} html The inner HTML to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetInnerHtml : function( html ) {\n\t\tthis.innerHtml = html;\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the inner HTML for the tag.\n\t *\n\t * @return {String}\n\t */\n\tgetInnerHtml : function() {\n\t\treturn this.innerHtml || \"\";\n\t},\n\n\n\t/**\n\t * Override of superclass method used to generate the HTML string for the tag.\n\t *\n\t * @return {String}\n\t */\n\ttoAnchorString : function() {\n\t\tvar tagName = this.getTagName(),\n\t\t    attrsStr = this.buildAttrsStr();\n\n\t\tattrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes\n\n\t\treturn [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( \"\" );\n\t},\n\n\n\t/**\n\t * Support method for {@link #toAnchorString}, returns the string space-separated key=\"value\" pairs, used to populate\n\t * the stringified HtmlTag.\n\t *\n\t * @protected\n\t * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n\t */\n\tbuildAttrsStr : function() {\n\t\tif( !this.attrs ) return \"\";  // no `attrs` Object (map) has been set, return empty string\n\n\t\tvar attrs = this.getAttrs(),\n\t\t    attrsArr = [];\n\n\t\tfor( var prop in attrs ) {\n\t\t\tif( attrs.hasOwnProperty( prop ) ) {\n\t\t\t\tattrsArr.push( prop + '=\"' + attrs[ prop ] + '\"' );\n\t\t\t}\n\t\t}\n\t\treturn attrsArr.join( \" \" );\n\t}\n\n} );\n\n/*global Autolinker */\n/*jshint sub:true */\n/**\n * @protected\n * @class Autolinker.AnchorTagBuilder\n * @extends Object\n *\n * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n *\n * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may\n * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n */\nAutolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {Boolean} newWindow\n\t * @inheritdoc Autolinker#newWindow\n\t */\n\n\t/**\n\t * @cfg {Number} truncate\n\t * @inheritdoc Autolinker#truncate\n\t */\n\n\t/**\n\t * @cfg {String} className\n\t * @inheritdoc Autolinker#className\n\t */\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\n\t/**\n\t * Generates the actual anchor (&lt;a&gt;) tag to use in place of the\n\t * matched text, via its `match` object.\n\t *\n\t * @param {Autolinker.match.Match} match The Match instance to generate an\n\t *   anchor tag from.\n\t * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n\t */\n\tbuild : function( match ) {\n\t\tvar tag = new Autolinker.HtmlTag( {\n\t\t\ttagName   : 'a',\n\t\t\tattrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),\n\t\t\tinnerHtml : this.processAnchorText( match.getAnchorText() )\n\t\t} );\n\n\t\treturn tag;\n\t},\n\n\n\t/**\n\t * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)\n\t *   tag being generated.\n\t *\n\t * @protected\n\t * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n\t *   match that an anchor tag is being generated for.\n\t * @param {String} href The href for the anchor tag.\n\t * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n\t */\n\tcreateAttrs : function( matchType, anchorHref ) {\n\t\tvar attrs = {\n\t\t\t'href' : anchorHref  // we'll always have the `href` attribute\n\t\t};\n\n\t\tvar cssClass = this.createCssClass( matchType );\n\t\tif( cssClass ) {\n\t\t\tattrs[ 'class' ] = cssClass;\n\t\t}\n\t\tif( this.newWindow ) {\n\t\t\tattrs[ 'target' ] = \"_blank\";\n\t\t}\n\n\t\treturn attrs;\n\t},\n\n\n\t/**\n\t * Creates the CSS class that will be used for a given anchor tag, based on\n\t * the `matchType` and the {@link #className} config.\n\t *\n\t * @private\n\t * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n\t *   match that an anchor tag is being generated for.\n\t * @return {String} The CSS class string for the link. Example return:\n\t *   \"myLink myLink-url\". If no {@link #className} was configured, returns\n\t *   an empty string.\n\t */\n\tcreateCssClass : function( matchType ) {\n\t\tvar className = this.className;\n\n\t\tif( !className )\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn className + \" \" + className + \"-\" + matchType;  // ex: \"myLink myLink-url\", \"myLink myLink-email\", \"myLink myLink-phone\", \"myLink myLink-twitter\", or \"myLink myLink-hashtag\"\n\t},\n\n\n\t/**\n\t * Processes the `anchorText` by truncating the text according to the\n\t * {@link #truncate} config.\n\t *\n\t * @private\n\t * @param {String} anchorText The anchor tag's text (i.e. what will be\n\t *   displayed).\n\t * @return {String} The processed `anchorText`.\n\t */\n\tprocessAnchorText : function( anchorText ) {\n\t\tanchorText = this.doTruncate( anchorText );\n\n\t\treturn anchorText;\n\t},\n\n\n\t/**\n\t * Performs the truncation of the `anchorText`, if the `anchorText` is\n\t * longer than the {@link #truncate} option. Truncates the text to 2\n\t * characters fewer than the {@link #truncate} option, and adds \"..\" to the\n\t * end.\n\t *\n\t * @private\n\t * @param {String} text The anchor tag's text (i.e. what will be displayed).\n\t * @return {String} The truncated anchor text.\n\t */\n\tdoTruncate : function( anchorText ) {\n\t\treturn Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @private\n * @class Autolinker.htmlParser.HtmlParser\n * @extends Object\n *\n * An HTML parser implementation which simply walks an HTML string and returns an array of\n * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n *\n * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / \"walking\n * around\" HTML tags.\n */\nAutolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @private\n\t * @property {RegExp} htmlRegex\n\t *\n\t * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n\t * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n\t *\n\t * Capturing groups:\n\t *\n\t * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n\t * 2. If it is an end tag, this group will have the '/'.\n\t * 3. If it is a comment tag, this group will hold the comment text (i.e.\n\t *    the text inside the `&lt;!--` and `--&gt;`.\n\t * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n\t */\n\thtmlRegex : (function() {\n\t\tvar commentTagRegex = /!--([\\s\\S]+?)--/,\n\t\t    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n\t\t    attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char\n\t\t    attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n\t\t    nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'\n\n\t\treturn new RegExp( [\n\t\t\t// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t'(?:',\n\t\t\t\t'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag\n\n\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\t'\\\\s+',  // one or more whitespace chars before an attribute\n\n\t\t\t\t\t\t// Either:\n\t\t\t\t\t\t// A. attr=\"value\", or\n\t\t\t\t\t\t// B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t\t\t\t'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',\n\t\t\t\t\t')*',\n\t\t\t\t'>',\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t// All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n\t\t\t'(?:',\n\t\t\t\t'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.\n\t\t\t\t          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\tcommentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text\n\n\t\t\t\t\t\t'|',\n\n\t\t\t\t\t\t'(?:',\n\n\t\t\t\t\t\t\t// *** Capturing Group 4 - The tag name\n\t\t\t\t\t\t\t'(' + tagNameRegex.source + ')',\n\n\t\t\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t\t\t'\\\\s+',                // one or more whitespace chars before an attribute\n\t\t\t\t\t\t\t\tnameEqualsValueRegex,  // attr=\"value\" (with optional =\"value\" part)\n\t\t\t\t\t\t\t')*',\n\n\t\t\t\t\t\t\t'\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n\n\t\t\t\t\t\t')',\n\t\t\t\t\t')',\n\t\t\t\t'>',\n\t\t\t')'\n\t\t].join( \"\" ), 'gi' );\n\t} )(),\n\n\t/**\n\t * @private\n\t * @property {RegExp} htmlCharacterEntitiesRegex\n\t *\n\t * The regular expression that matches common HTML character entities.\n\t *\n\t * Ignoring &amp; as it could be part of a query string -- handling it separately.\n\t */\n\thtmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n\n\n\t/**\n\t * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n\t * to represent the HTML structure of the input string.\n\t *\n\t * @param {String} html The HTML to parse.\n\t * @return {Autolinker.htmlParser.HtmlNode[]}\n\t */\n\tparse : function( html ) {\n\t\tvar htmlRegex = this.htmlRegex,\n\t\t    currentResult,\n\t\t    lastIndex = 0,\n\t\t    textAndEntityNodes,\n\t\t    nodes = [];  // will be the result of the method\n\n\t\twhile( ( currentResult = htmlRegex.exec( html ) ) !== null ) {\n\t\t\tvar tagText = currentResult[ 0 ],\n\t\t\t    commentText = currentResult[ 3 ], // if we've matched a comment\n\t\t\t    tagName = currentResult[ 1 ] || currentResult[ 4 ],  // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n\t\t\t    isClosingTag = !!currentResult[ 2 ],\n\t\t\t    inBetweenTagsText = html.substring( lastIndex, currentResult.index );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( inBetweenTagsText ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );\n\t\t\t\tnodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t}\n\n\t\t\t// Push the CommentNode or ElementNode\n\t\t\tif( commentText ) {\n\t\t\t\tnodes.push( this.createCommentNode( tagText, commentText ) );\n\t\t\t} else {\n\t\t\t\tnodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );\n\t\t\t}\n\n\t\t\tlastIndex = currentResult.index + tagText.length;\n\t\t}\n\n\t\t// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n\t\tif( lastIndex < html.length ) {\n\t\t\tvar text = html.substring( lastIndex );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( text ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( text );\n\t\t\t\tnodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t},\n\n\n\t/**\n\t * Parses text and HTML entity nodes from a given string. The input string\n\t * should not have any HTML tags (elements) within it.\n\t *\n\t * @private\n\t * @param {String} text The text to parse.\n\t * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n\t *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n\t *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n\t */\n\tparseTextAndEntityNodes : function( text ) {\n\t\tvar nodes = [],\n\t\t    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array\n\n\t\t// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n\t\t// For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n\t\t//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n\t\tfor( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {\n\t\t\tvar textToken = textAndEntityTokens[ i ],\n\t\t\t    entityToken = textAndEntityTokens[ i + 1 ];\n\n\t\t\tif( textToken ) nodes.push( this.createTextNode( textToken ) );\n\t\t\tif( entityToken ) nodes.push( this.createEntityNode( entityToken ) );\n\t\t}\n\t\treturn nodes;\n\t},\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n\t *\n\t * @private\n\t * @param {String} tagText The full text of the tag (comment) that was\n\t *   matched, including its &lt;!-- and --&gt;.\n\t * @param {String} comment The full text of the comment that was matched.\n\t */\n\tcreateCommentNode : function( tagText, commentText ) {\n\t\treturn new Autolinker.htmlParser.CommentNode( {\n\t\t\ttext: tagText,\n\t\t\tcomment: Autolinker.Util.trim( commentText )\n\t\t} );\n\t},\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n\t *\n\t * @private\n\t * @param {String} tagText The full text of the tag (element) that was\n\t *   matched, including its attributes.\n\t * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n\t *   be passed to this method as \"img\".\n\t * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n\t *   otherwise.\n\t * @return {Autolinker.htmlParser.ElementNode}\n\t */\n\tcreateElementNode : function( tagText, tagName, isClosingTag ) {\n\t\treturn new Autolinker.htmlParser.ElementNode( {\n\t\t\ttext    : tagText,\n\t\t\ttagName : tagName.toLowerCase(),\n\t\t\tclosing : isClosingTag\n\t\t} );\n\t},\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n\t *\n\t * @private\n\t * @param {String} text The text that was matched for the HTML entity (such\n\t *   as '&amp;nbsp;').\n\t * @return {Autolinker.htmlParser.EntityNode}\n\t */\n\tcreateEntityNode : function( text ) {\n\t\treturn new Autolinker.htmlParser.EntityNode( { text: text } );\n\t},\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n\t *\n\t * @private\n\t * @param {String} text The text that was matched.\n\t * @return {Autolinker.htmlParser.TextNode}\n\t */\n\tcreateTextNode : function( text ) {\n\t\treturn new Autolinker.htmlParser.TextNode( { text: text } );\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @abstract\n * @class Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML node found in an input string. An HTML node is one of the\n * following:\n *\n * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents\n *    HTML tags.\n * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents\n *    HTML comments.\n * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text\n *    outside or within HTML tags.\n * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents\n *    one of the known HTML entities that Autolinker looks for. This includes\n *    common ones such as &amp;quot; and &amp;nbsp;\n */\nAutolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {String} text (required)\n\t *\n\t * The original text that was matched for the HtmlNode.\n\t *\n\t * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},\n\t *   this will be the tag's text.\n\t * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},\n\t *   this will be the comment's text.\n\t * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this\n\t *   will be the text itself.\n\t * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},\n\t *   this will be the text of the HTML entity.\n\t */\n\ttext : \"\",\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} cfg The configuration properties for the Match instance,\n\t * specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @abstract\n\t * @return {String}\n\t */\n\tgetType : Autolinker.Util.abstractMethod,\n\n\n\t/**\n\t * Retrieves the {@link #text} for the HtmlNode.\n\t *\n\t * @return {String}\n\t */\n\tgetText : function() {\n\t\treturn this.text;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.CommentNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML comment node that has been parsed by the\n * {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nAutolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n\t/**\n\t * @cfg {String} comment (required)\n\t *\n\t * The text inside the comment tag. This text is stripped of any leading or\n\t * trailing whitespace.\n\t */\n\tcomment : '',\n\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'comment';\n\t},\n\n\n\t/**\n\t * Returns the comment inside the comment tag.\n\t *\n\t * @return {String}\n\t */\n\tgetComment : function() {\n\t\treturn this.comment;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.ElementNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nAutolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n\t/**\n\t * @cfg {String} tagName (required)\n\t *\n\t * The name of the tag that was matched.\n\t */\n\ttagName : '',\n\n\t/**\n\t * @cfg {Boolean} closing (required)\n\t *\n\t * `true` if the element (tag) is a closing tag, `false` if its an opening\n\t * tag.\n\t */\n\tclosing : false,\n\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'element';\n\t},\n\n\n\t/**\n\t * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,\n\t * returns \"img\".\n\t *\n\t * @return {String}\n\t */\n\tgetTagName : function() {\n\t\treturn this.tagName;\n\t},\n\n\n\t/**\n\t * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;\n\t * returns `false`, while &lt;/div&gt; returns `true`.\n\t *\n\t * @return {Boolean}\n\t */\n\tisClosing : function() {\n\t\treturn this.closing;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.EntityNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}\n * method.\n *\n * Note that this class will only be returned from the HtmlParser for the set of\n * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nAutolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'entity';\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.TextNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nAutolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'text';\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @private\n * @class Autolinker.matchParser.MatchParser\n * @extends Object\n *\n * Used by Autolinker to parse potential matches, given an input string of text.\n *\n * The MatchParser is fed a non-HTML string in order to search for matches.\n * Autolinker first uses the {@link Autolinker.htmlParser.HtmlParser} to \"walk\n * around\" HTML tags, and then the text around the HTML tags is passed into the\n * MatchParser in order to find the actual matches.\n */\nAutolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {Boolean} urls\n\t * @inheritdoc Autolinker#urls\n\t */\n\turls : true,\n\n\t/**\n\t * @cfg {Boolean} email\n\t * @inheritdoc Autolinker#email\n\t */\n\temail : true,\n\n\t/**\n\t * @cfg {Boolean} twitter\n\t * @inheritdoc Autolinker#twitter\n\t */\n\ttwitter : true,\n\n\t/**\n\t * @cfg {Boolean} phone\n\t * @inheritdoc Autolinker#phone\n\t */\n\tphone: true,\n\n\t/**\n\t * @cfg {Boolean/String} hashtag\n\t * @inheritdoc Autolinker#hashtag\n\t */\n\thashtag : false,\n\n\t/**\n\t * @cfg {Boolean} stripPrefix\n\t * @inheritdoc Autolinker#stripPrefix\n\t */\n\tstripPrefix : true,\n\n\n\t/**\n\t * @private\n\t * @property {RegExp} matcherRegex\n\t *\n\t * The regular expression that matches URLs, email addresses, phone #s,\n\t * Twitter handles, and Hashtags.\n\t *\n\t * This regular expression has the following capturing groups:\n\t *\n\t * 1.  Group that is used to determine if there is a Twitter handle match\n\t *     (i.e. \\@someTwitterUser). Simply check for its existence to determine\n\t *     if there is a Twitter handle match. The next couple of capturing\n\t *     groups give information about the Twitter handle match.\n\t * 2.  The whitespace character before the \\@sign in a Twitter handle. This\n\t *     is needed because there are no lookbehinds in JS regular expressions,\n\t *     and can be used to reconstruct the original string in a replace().\n\t * 3.  The Twitter handle itself in a Twitter match. If the match is\n\t *     '@someTwitterUser', the handle is 'someTwitterUser'.\n\t * 4.  Group that matches an email address. Used to determine if the match\n\t *     is an email address, as well as holding the full address. Ex:\n\t *     'me@my.com'\n\t * 5.  Group that matches a URL in the input text. Ex: 'http://google.com',\n\t *     'www.google.com', or just 'google.com'. This also includes a path,\n\t *     url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n\t * 6.  Group that matches a protocol URL (i.e. 'http://google.com'). This is\n\t *     used to match protocol URLs with just a single word, like 'http://localhost',\n\t *     where we won't double check that the domain name has at least one '.'\n\t *     in it.\n\t * 7.  A protocol-relative ('//') match for the case of a 'www.' prefixed\n\t *     URL. Will be an empty string if it is not a protocol-relative match.\n\t *     We need to know the character before the '//' in order to determine\n\t *     if it is a valid match or the // was in a string we don't want to\n\t *     auto-link.\n\t * 8.  A protocol-relative ('//') match for the case of a known TLD prefixed\n\t *     URL. Will be an empty string if it is not a protocol-relative match.\n\t *     See #6 for more info.\n\t * 9.  Group that is used to determine if there is a phone number match. The\n\t *     next 3 groups give segments of the phone number.\n\t * 10. Group that is used to determine if there is a Hashtag match\n\t *     (i.e. \\#someHashtag). Simply check for its existence to determine if\n\t *     there is a Hashtag match. The next couple of capturing groups give\n\t *     information about the Hashtag match.\n\t * 11. The whitespace character before the #sign in a Hashtag handle. This\n\t *     is needed because there are no look-behinds in JS regular\n\t *     expressions, and can be used to reconstruct the original string in a\n\t *     replace().\n\t * 12. The Hashtag itself in a Hashtag match. If the match is\n\t *     '#someHashtag', the hashtag is 'someHashtag'.\n\t */\n\tmatcherRegex : (function() {\n\t\tvar twitterRegex = /(^|[^\\w])@(\\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs\n\n\t\t    hashtagRegex = /(^|[^\\w])#(\\w{1,139})/,              // For matching a Hashtag. Ex: #games\n\n\t\t    emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,             // something@ for email addresses (a.k.a. local-part)\n\t\t    phoneRegex = /(?:\\+?\\d{1,3}[-\\040.])?\\(?\\d{3}\\)?[-\\040.]?\\d{3}[-\\040.]\\d{4}/,  // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.\n\t\t    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]*:(?![A-Za-z][-.+A-Za-z0-9]*:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,  // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n\t\t    wwwRegex = /(?:www\\.)/,                             // starting with 'www.'\n\t\t    domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period\n\t\t    tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|press|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,   // match our known top level domains (TLDs)\n\n\t\t    // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n\t\t    // http://blog.codinghorror.com/the-problem-with-urls/\n\t\t    urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n\n\t\treturn new RegExp( [\n\t\t\t'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()\n\t\t\t\t// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and\n\t\t\t\t// *** Capturing group $3, which matches the actual twitter handle\n\t\t\t\ttwitterRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $4, which is used to determine an email match\n\t\t\t\temailRegex.source,\n\t\t\t\tdomainNameRegex.source,\n\t\t\t\ttldRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $5, which is used to match a URL\n\t\t\t\t'(?:', // parens to cover match for protocol (optional), and domain\n\t\t\t\t\t'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n\t\t\t\t\t\tprotocolRegex.source,\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t')',\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\twwwRegex.source,\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t')',\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t'(?:',  // non-capturing paren for known a TLD url (ex: google.com)\n\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t\ttldRegex.source,\n\t\t\t\t\t')',\n\t\t\t\t')',\n\n\t\t\t\t'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t// this setup does not scale well for open extension :( Need to rethink design of autolinker...\n\t\t\t// ***  Capturing group $9, which matches a (USA for now) phone number\n\t\t\t'(',\n\t\t\t\tphoneRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $10, which can be used to check for a Hashtag match. Use group $12 for the actual Hashtag though. $11 may be used to reconstruct the original string in a replace()\n\t\t\t\t// *** Capturing group $11, which matches the whitespace character before the '#' sign (needed because of no lookbehinds), and\n\t\t\t\t// *** Capturing group $12, which matches the actual Hashtag\n\t\t\t\thashtagRegex.source,\n\t\t\t')'\n\t\t].join( \"\" ), 'gi' );\n\t} )(),\n\n\t/**\n\t * @private\n\t * @property {RegExp} charBeforeProtocolRelMatchRegex\n\t *\n\t * The regular expression used to retrieve the character before a\n\t * protocol-relative URL match.\n\t *\n\t * This is used in conjunction with the {@link #matcherRegex}, which needs\n\t * to grab the character before a protocol-relative '//' due to the lack of\n\t * a negative look-behind in JavaScript regular expressions. The character\n\t * before the match is stripped from the URL.\n\t */\n\tcharBeforeProtocolRelMatchRegex : /^(.)?\\/\\//,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.MatchValidator} matchValidator\n\t *\n\t * The MatchValidator object, used to filter out any false positives from\n\t * the {@link #matcherRegex}. See {@link Autolinker.MatchValidator} for details.\n\t */\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration options for the AnchorTagBuilder\n\t * instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\n\t\tthis.matchValidator = new Autolinker.MatchValidator();\n\t},\n\n\n\t/**\n\t * Parses the input `text` to search for matches, and calls the `replaceFn`\n\t * to allow replacements of the matches. Returns the `text` with matches\n\t * replaced.\n\t *\n\t * @param {String} text The text to search and repace matches in.\n\t * @param {Function} replaceFn The iterator function to handle the\n\t *   replacements. The function takes a single argument, a {@link Autolinker.match.Match}\n\t *   object, and should return the text that should make the replacement.\n\t * @param {Object} [contextObj=window] The context object (\"scope\") to run\n\t *   the `replaceFn` in.\n\t * @return {String}\n\t */\n\treplace : function( text, replaceFn, contextObj ) {\n\t\tvar me = this;  // for closure\n\n\t\treturn text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ) {\n\t\t\tvar matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 );  // \"match description\" object\n\n\t\t\t// Return out with no changes for match types that are disabled (url,\n\t\t\t// email, phone, etc.), or for matches that are invalid (false\n\t\t\t// positives from the matcherRegex, which can't use look-behinds\n\t\t\t// since they are unavailable in JS).\n\t\t\tif( !matchDescObj ) {\n\t\t\t\treturn matchStr;\n\n\t\t\t} else {\n\t\t\t\t// Generate replacement text for the match from the `replaceFn`\n\t\t\t\tvar replaceStr = replaceFn.call( contextObj, matchDescObj.match );\n\t\t\t\treturn matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;\n\t\t\t}\n\t\t} );\n\t},\n\n\n\t/**\n\t * Processes a candidate match from the {@link #matcherRegex}.\n\t *\n\t * Not all matches found by the regex are actual URL/Email/Phone/Twitter/Hashtag\n\t * matches, as determined by the {@link #matchValidator}. In this case, the\n\t * method returns `null`. Otherwise, a valid Object with `prefixStr`,\n\t * `match`, and `suffixStr` is returned.\n\t *\n\t * @private\n\t * @param {String} matchStr The full match that was found by the\n\t *   {@link #matcherRegex}.\n\t * @param {String} twitterMatch The matched text of a Twitter handle, if the\n\t *   match is a Twitter match.\n\t * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char\n\t *   before the @ sign in a Twitter handle match. This is needed because of\n\t *   no lookbehinds in JS regexes, and is need to re-include the character\n\t *   for the anchor tag replacement.\n\t * @param {String} twitterHandle The actual Twitter user (i.e the word after\n\t *   the @ sign in a Twitter match).\n\t * @param {String} emailAddressMatch The matched email address for an email\n\t *   address match.\n\t * @param {String} urlMatch The matched URL string for a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative\n\t *   match from a 'www' url, with the character that comes before the '//'.\n\t * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative\n\t *   match from a TLD (top level domain) match, with the character that\n\t *   comes before the '//'.\n\t * @param {String} phoneMatch The matched text of a phone number\n\t * @param {String} hashtagMatch The matched text of a Twitter\n\t *   Hashtag, if the match is a Hashtag match.\n\t * @param {String} hashtagPrefixWhitespaceChar The whitespace char\n\t *   before the # sign in a Hashtag match. This is needed because of no\n\t *   lookbehinds in JS regexes, and is need to re-include the character for\n\t *   the anchor tag replacement.\n\t * @param {String} hashtag The actual Hashtag (i.e the word\n\t *   after the # sign in a Hashtag match).\n\t *\n\t * @return {Object} A \"match description object\". This will be `null` if the\n\t *   match was invalid, or if a match type is disabled. Otherwise, this will\n\t *   be an Object (map) with the following properties:\n\t * @return {String} return.prefixStr The char(s) that should be prepended to\n\t *   the replacement string. These are char(s) that were needed to be\n\t *   included from the regex match that were ignored by processing code, and\n\t *   should be re-inserted into the replacement stream.\n\t * @return {String} return.suffixStr The char(s) that should be appended to\n\t *   the replacement string. These are char(s) that were needed to be\n\t *   included from the regex match that were ignored by processing code, and\n\t *   should be re-inserted into the replacement stream.\n\t * @return {Autolinker.match.Match} return.match The Match object that\n\t *   represents the match that was found.\n\t */\n\tprocessCandidateMatch : function(\n\t\tmatchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,\n\t\temailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch,\n\t\ttldProtocolRelativeMatch, phoneMatch, hashtagMatch,\n\t\thashtagPrefixWhitespaceChar, hashtag\n\t) {\n\t\t// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will\n\t\t// be added to `prefixStr` and `suffixStr`).\n\n\t\tvar protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n\t\t    match,  // Will be an Autolinker.match.Match object\n\n\t\t    prefixStr = \"\",  // A string to use to prefix the anchor tag that is created. This is needed for the Twitter and Hashtag matches.\n\t\t    suffixStr = \"\";  // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n\n\t\t// Return out with `null` for match types that are disabled (url, email,\n\t\t// twitter, hashtag), or for matches that are invalid (false positives\n\t\t// from the matcherRegex, which can't use look-behinds since they are\n\t\t// unavailable in JS).\n\t\tif(\n\t\t\t( urlMatch && !this.urls ) ||\n\t\t\t( emailAddressMatch && !this.email ) ||\n\t\t\t( phoneMatch && !this.phone ) ||\n\t\t\t( twitterMatch && !this.twitter ) ||\n\t\t\t( hashtagMatch && !this.hashtag ) ||\n\t\t\t!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Handle a closing parenthesis at the end of the match, and exclude it\n\t\t// if there is not a matching open parenthesis\n\t\t// in the match itself.\n\t\tif( this.matchHasUnbalancedClosingParen( matchStr ) ) {\n\t\t\tmatchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing \")\"\n\t\t\tsuffixStr = \")\";  // this will be added after the generated <a> tag\n\t\t} else {\n\t\t\t// Handle an invalid character after the TLD\n\t\t\tvar pos = this.matchHasInvalidCharAfterTld( urlMatch, protocolUrlMatch );\n\t\t\tif( pos > -1 ) {\n\t\t\t\tsuffixStr = matchStr.substr(pos);  // this will be added after the generated <a> tag\n\t\t\t\tmatchStr = matchStr.substr( 0, pos ); // remove the trailing invalid chars\n\t\t\t}\n\t\t}\n\n\t\tif( emailAddressMatch ) {\n\t\t\tmatch = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );\n\n\t\t} else if( twitterMatch ) {\n\t\t\t// fix up the `matchStr` if there was a preceding whitespace char,\n\t\t\t// which was needed to determine the match itself (since there are\n\t\t\t// no look-behinds in JS regexes)\n\t\t\tif( twitterHandlePrefixWhitespaceChar ) {\n\t\t\t\tprefixStr = twitterHandlePrefixWhitespaceChar;\n\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n\t\t\t}\n\t\t\tmatch = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );\n\n\t\t} else if( phoneMatch ) {\n\t\t\t// remove non-numeric values from phone number string\n\t\t\tvar cleanNumber = matchStr.replace( /\\D/g, '' );\n \t\t\tmatch = new Autolinker.match.Phone( { matchedText: matchStr, number: cleanNumber } );\n\n\t\t} else if( hashtagMatch ) {\n\t\t\t// fix up the `matchStr` if there was a preceding whitespace char,\n\t\t\t// which was needed to determine the match itself (since there are\n\t\t\t// no look-behinds in JS regexes)\n\t\t\tif( hashtagPrefixWhitespaceChar ) {\n\t\t\t\tprefixStr = hashtagPrefixWhitespaceChar;\n\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n\t\t\t}\n\t\t\tmatch = new Autolinker.match.Hashtag( { matchedText: matchStr, serviceName: this.hashtag, hashtag: hashtag } );\n\n\t\t} else {  // url match\n\t\t\t// If it's a protocol-relative '//' match, remove the character\n\t\t\t// before the '//' (which the matcherRegex needed to match due to\n\t\t\t// the lack of a negative look-behind in JavaScript regular\n\t\t\t// expressions)\n\t\t\tif( protocolRelativeMatch ) {\n\t\t\t\tvar charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || \"\";\n\n\t\t\t\tif( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n\t\t\t\t\tprefixStr = charBeforeMatch;\n\t\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed char from the match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmatch = new Autolinker.match.Url( {\n\t\t\t\tmatchedText : matchStr,\n\t\t\t\turl : matchStr,\n\t\t\t\tprotocolUrlMatch : !!protocolUrlMatch,\n\t\t\t\tprotocolRelativeMatch : !!protocolRelativeMatch,\n\t\t\t\tstripPrefix : this.stripPrefix\n\t\t\t} );\n\t\t}\n\n\t\treturn {\n\t\t\tprefixStr : prefixStr,\n\t\t\tsuffixStr : suffixStr,\n\t\t\tmatch     : match\n\t\t};\n\t},\n\n\n\t/**\n\t * Determines if a match found has an unmatched closing parenthesis. If so,\n\t * this parenthesis will be removed from the match itself, and appended\n\t * after the generated anchor tag in {@link #processCandidateMatch}.\n\t *\n\t * A match may have an extra closing parenthesis at the end of the match\n\t * because the regular expression must include parenthesis for URLs such as\n\t * \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n\t *\n\t * However, an extra parenthesis *will* be included when the URL itself is\n\t * wrapped in parenthesis, such as in the case of \"(wikipedia.com/something_(disambiguation))\".\n\t * In this case, the last closing parenthesis should *not* be part of the\n\t * URL itself, and this method will return `true`.\n\t *\n\t * @private\n\t * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n\t * @return {Boolean} `true` if there is an unbalanced closing parenthesis at\n\t *   the end of the `matchStr`, `false` otherwise.\n\t */\n\tmatchHasUnbalancedClosingParen : function( matchStr ) {\n\t\tvar lastChar = matchStr.charAt( matchStr.length - 1 );\n\n\t\tif( lastChar === ')' ) {\n\t\t\tvar openParensMatch = matchStr.match( /\\(/g ),\n\t\t\t    closeParensMatch = matchStr.match( /\\)/g ),\n\t\t\t    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,\n\t\t\t    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;\n\n\t\t\tif( numOpenParens < numCloseParens ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\n\t/**\n\t * Determine if there's an invalid character after the TLD in a URL. Valid\n\t * characters after TLD are ':/?#'. Exclude protocol matched URLs from this\n\t * check.\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Number} the position where the invalid character was found. If\n\t *   no such character was found, returns -1\n\t */\n\tmatchHasInvalidCharAfterTld : function( urlMatch, protocolUrlMatch ) {\n\t\tif ( !urlMatch ) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tvar offset = 0;\n\t\tif ( protocolUrlMatch ) {\n\t\t\toffset = urlMatch.indexOf(':');\n\t\t\turlMatch = urlMatch.slice(offset);\n\t\t}\n\n\t\tvar re = /^((.?\\/\\/)?[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]\\.[A-Za-z]+)/;\n\t\tvar res = re.exec( urlMatch );\n\t\tif ( res === null ) {\n\t\t\treturn -1;\n\t\t}\n\n\t\toffset += res[1].length;\n\t\turlMatch = urlMatch.slice(res[1].length);\n\t\tif (/^[^.A-Za-z:\\/?#]/.test(urlMatch)) {\n\t\t\treturn offset;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n} );\n\n/*global Autolinker */\n/*jshint scripturl:true */\n/**\n * @private\n * @class Autolinker.MatchValidator\n * @extends Object\n *\n * Used by Autolinker to filter out false positives from the\n * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n */\nAutolinker.MatchValidator = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @private\n\t * @property {RegExp} invalidProtocolRelMatchRegex\n\t *\n\t * The regular expression used to check a potential protocol-relative URL\n\t * match, coming from the {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n\t * A protocol-relative URL is, for example, \"//yahoo.com\"\n\t *\n\t * This regular expression checks to see if there is a word character before\n\t * the '//' match in order to determine if we should actually autolink a\n\t * protocol-relative URL. This is needed because there is no negative\n\t * look-behind in JavaScript regular expressions.\n\t *\n\t * For instance, we want to autolink something like \"Go to: //google.com\",\n\t * but we don't want to autolink something like \"abc//google.com\"\n\t */\n\tinvalidProtocolRelMatchRegex : /^[\\w]\\/\\//,\n\n\t/**\n\t * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n\t *\n\t * @private\n\t * @property {RegExp} hasFullProtocolRegex\n\t */\n\thasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//,\n\n\t/**\n\t * Regex to find the URI scheme, such as 'mailto:'.\n\t *\n\t * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n\t *\n\t * @private\n\t * @property {RegExp} uriSchemeRegex\n\t */\n\turiSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]*:/,\n\n\t/**\n\t * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n\t *\n\t * @private\n\t * @property {RegExp} hasWordCharAfterProtocolRegex\n\t */\n\thasWordCharAfterProtocolRegex : /:[^\\s]*?[A-Za-z]/,\n\n\n\t/**\n\t * Determines if a given match found by the {@link Autolinker.matchParser.MatchParser}\n\t * is valid. Will return `false` for:\n\t *\n\t * 1) URL matches which do not have at least have one period ('.') in the\n\t *    domain name (effectively skipping over matches like \"abc:def\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n\t * 2) URL matches which do not have at least one word character in the\n\t *    domain name (effectively skipping over matches like \"git:1.0\").\n\t * 3) A protocol-relative url match (a URL beginning with '//') whose\n\t *    previous character is a word character (effectively skipping over\n\t *    strings like \"abc//google.com\")\n\t *\n\t * Otherwise, returns `true`.\n\t *\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @param {String} protocolRelativeMatch The protocol-relative string for a\n\t *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n\t *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n\t *   invalid if there is a word character preceding the '//'.\n\t * @return {Boolean} `true` if the match given is valid and should be\n\t *   processed, or `false` if the match is invalid and/or should just not be\n\t *   processed.\n\t */\n\tisValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {\n\t\tif(\n\t\t\t( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n\t\t\tthis.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n\t\t\tthis.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n\t\t\tthis.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\n\t/**\n\t * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n\t * `false` if the scheme is 'javascript:' or 'vbscript:'\n\t *\n\t * @private\n\t * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n\t *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n\t * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n\t */\n\tisValidUriScheme : function( uriSchemeMatch ) {\n\t\tvar uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();\n\n\t\treturn ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n\t},\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http://'), or\n\t * b) at least one dot ('.') in the domain name (for a non-full-protocol\n\t *    match).\n\t *\n\t * Either situation is considered an invalid URL (ex: 'git:d' does not have\n\t * either the '://' part, or at least one dot in the domain name. If the\n\t * match was 'git:abc.com', we would consider this valid.)\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the URL match does not have a full protocol,\n\t *   or at least one dot ('.') in a non-full-protocol match.\n\t */\n\turlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {\n\t\treturn ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n\t},\n\n\n\t/**\n\t * Determines if a URL match does not have at least one word character after\n\t * the protocol (i.e. in the domain name).\n\t *\n\t * At least one letter character must exist in the domain name after a\n\t * protocol match. Ex: skip over something like \"git:1.0\"\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n\t *   have a protocol in the URL string, in order to check for a word\n\t *   character after the protocol separator (':').\n\t * @return {Boolean} `true` if the URL match does not have at least one word\n\t *   character in it after the protocol, `false` otherwise.\n\t */\n\turlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {\n\t\tif( urlMatch && protocolUrlMatch ) {\n\t\t\treturn !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\n\n\t/**\n\t * Determines if a protocol-relative match is an invalid one. This method\n\t * returns `true` if there is a `protocolRelativeMatch`, and that match\n\t * contains a word character before the '//' (i.e. it must contain\n\t * whitespace or nothing before the '//' in order to be considered valid).\n\t *\n\t * @private\n\t * @param {String} protocolRelativeMatch The protocol-relative string for a\n\t *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n\t *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n\t *   invalid if there is a word character preceding the '//'.\n\t * @return {Boolean} `true` if it is an invalid protocol-relative match,\n\t *   `false` otherwise.\n\t */\n\tisInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {\n\t\treturn ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );\n\t}\n\n} );\n\n/*global Autolinker */\n/**\n * @abstract\n * @class Autolinker.match.Match\n * \n * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a \n * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n * \n * For example:\n * \n *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n *     \n *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *         \n *             switch( match.getType() ) {\n *                 case 'url' : \n *                     console.log( \"url: \", match.getUrl() );\n *                     \n *                 case 'email' :\n *                     console.log( \"email: \", match.getEmail() );\n *                     \n *                 case 'twitter' :\n *                     console.log( \"twitter: \", match.getTwitterHandle() );\n *             }\n *         }\n *     } );\n *     \n * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n */\nAutolinker.match.Match = Autolinker.Util.extend( Object, {\n\t\n\t/**\n\t * @cfg {String} matchedText (required)\n\t * \n\t * The original text that was matched.\n\t */\n\t\n\t\n\t/**\n\t * @constructor\n\t * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\t\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetType : Autolinker.Util.abstractMethod,\n\t\n\t\n\t/**\n\t * Returns the original text that was matched.\n\t * \n\t * @return {String}\n\t */\n\tgetMatchedText : function() {\n\t\treturn this.matchedText;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetAnchorHref : Autolinker.Util.abstractMethod,\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetAnchorText : Autolinker.Util.abstractMethod\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Email\n * @extends Autolinker.match.Match\n * \n * Represents a Email match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} email (required)\n\t * \n\t * The email address that was matched.\n\t */\n\t\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'email';\n\t},\n\t\n\t\n\t/**\n\t * Returns the email address that was matched.\n\t * \n\t * @return {String}\n\t */\n\tgetEmail : function() {\n\t\treturn this.email;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'mailto:' + this.email;\n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn this.email;\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Hashtag\n * @extends Autolinker.match.Match\n *\n * Represents a Hashtag match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nAutolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t/**\n\t * @cfg {String} serviceName (required)\n\t *\n\t * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n\t * for available values.\n\t */\n\n\t/**\n\t * @cfg {String} hashtag (required)\n\t *\n\t * The Hashtag that was matched, without the '#'.\n\t */\n\n\n\t/**\n\t * Returns the type of match that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'hashtag';\n\t},\n\n\n\t/**\n\t * Returns the matched hashtag.\n\t *\n\t * @return {String}\n\t */\n\tgetHashtag : function() {\n\t\treturn this.hashtag;\n\t},\n\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\tvar serviceName = this.serviceName,\n\t\t    hashtag = this.hashtag;\n\n\t\tswitch( serviceName ) {\n\t\t\tcase 'twitter' :\n\t\t\t\treturn 'https://twitter.com/hashtag/' + hashtag;\n\t\t\tcase 'facebook' :\n\t\t\t\treturn 'https://www.facebook.com/hashtag/' + hashtag;\n\t\t\tcase 'instagram' :\n\t\t\t\treturn 'https://instagram.com/explore/tags/' + hashtag;\n\n\t\t\tdefault :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n\t\t\t\tthrow new Error( 'Unknown service name to point hashtag to: ', serviceName );\n\t\t}\n\t},\n\n\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn '#' + this.hashtag;\n\t}\n\n} );\n\n/*global Autolinker */\n/**\n * @class Autolinker.match.Phone\n * @extends Autolinker.match.Match\n *\n * Represents a Phone number match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nAutolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t/**\n\t * @cfg {String} number (required)\n\t *\n\t * The phone number that was matched.\n\t */\n\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'phone';\n\t},\n\n\n\t/**\n\t * Returns the phone number that was matched.\n\t *\n\t * @return {String}\n\t */\n\tgetNumber: function() {\n\t\treturn this.number;\n\t},\n\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'tel:' + this.number;\n\t},\n\n\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn this.matchedText;\n\t}\n\n} );\n\n/*global Autolinker */\n/**\n * @class Autolinker.match.Twitter\n * @extends Autolinker.match.Match\n * \n * Represents a Twitter match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} twitterHandle (required)\n\t * \n\t * The Twitter handle that was matched.\n\t */\n\t\n\n\t/**\n\t * Returns the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'twitter';\n\t},\n\t\n\t\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetTwitterHandle : function() {\n\t\treturn this.twitterHandle;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'https://twitter.com/' + this.twitterHandle;\n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn '@' + this.twitterHandle;\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Url\n * @extends Autolinker.match.Match\n * \n * Represents a Url match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} url (required)\n\t * \n\t * The url that was matched.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} protocolUrlMatch (required)\n\t * \n\t * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or\n\t * known TLD match.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} protocolRelativeMatch (required)\n\t * \n\t * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n\t * and will be either http:// or https:// based on the protocol that the site is loaded under.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} stripPrefix (required)\n\t * @inheritdoc Autolinker#stripPrefix\n\t */\n\t\n\n\t/**\n\t * @private\n\t * @property {RegExp} urlPrefixRegex\n\t * \n\t * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.\n\t */\n\turlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n\t\n\t/**\n\t * @private\n\t * @property {RegExp} protocolRelativeRegex\n\t * \n\t * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n\t * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n\t */\n\tprotocolRelativeRegex : /^\\/\\//,\n\t\n\t/**\n\t * @private\n\t * @property {Boolean} protocolPrepended\n\t * \n\t * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n\t * {@link #url} did not have a protocol)\n\t */\n\tprotocolPrepended : false,\n\t\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'url';\n\t},\n\t\n\t\n\t/**\n\t * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n\t * match was missing a protocol.\n\t * \n\t * @return {String}\n\t */\n\tgetUrl : function() {\n\t\tvar url = this.url;\n\t\t\n\t\t// if the url string doesn't begin with a protocol, assume 'http://'\n\t\tif( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {\n\t\t\turl = this.url = 'http://' + url;\n\t\t\t\n\t\t\tthis.protocolPrepended = true;\n\t\t}\n\t\t\n\t\treturn url;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\tvar url = this.getUrl();\n\t\t\n\t\treturn url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html \n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\tvar anchorText = this.getUrl();\n\t\t\n\t\tif( this.protocolRelativeMatch ) {\n\t\t\t// Strip off any protocol-relative '//' from the anchor text\n\t\t\tanchorText = this.stripProtocolRelativePrefix( anchorText );\n\t\t}\n\t\tif( this.stripPrefix ) {\n\t\t\tanchorText = this.stripUrlPrefix( anchorText );\n\t\t}\n\t\tanchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one\n\t\t\n\t\treturn anchorText;\n\t},\n\t\n\t\n\t// ---------------------------------------\n\t\n\t// Utility Functionality\n\t\n\t/**\n\t * Strips the URL prefix (such as \"http://\" or \"https://\") from the given text.\n\t * \n\t * @private\n\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t *   url prefix (such as stripping off \"http://\")\n\t * @return {String} The `anchorText`, with the prefix stripped.\n\t */\n\tstripUrlPrefix : function( text ) {\n\t\treturn text.replace( this.urlPrefixRegex, '' );\n\t},\n\t\n\t\n\t/**\n\t * Strips any protocol-relative '//' from the anchor text.\n\t * \n\t * @private\n\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t *   protocol-relative prefix (such as stripping off \"//\")\n\t * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n\t */\n\tstripProtocolRelativePrefix : function( text ) {\n\t\treturn text.replace( this.protocolRelativeRegex, '' );\n\t},\n\t\n\t\n\t/**\n\t * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n\t * \n\t * @private\n\t * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n\t *   slash ('/') that may exist.\n\t * @return {String} The `anchorText`, with the trailing slash removed.\n\t */\n\tremoveTrailingSlash : function( anchorText ) {\n\t\tif( anchorText.charAt( anchorText.length - 1 ) === '/' ) {\n\t\t\tanchorText = anchorText.slice( 0, -1 );\n\t\t}\n\t\treturn anchorText;\n\t}\n\t\n} );\nreturn Autolinker;\n\n}));\n"],"mappings":"AAAC,WAAUA,IAAI,EAAEC,OAAO,EAAE;EACxB,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,EAAE;IAC9C;IACAD,MAAM,CAAC,EAAE,EAAE,YAAY;MACrB,OAAQF,IAAI,CAAC,YAAY,CAAC,GAAGC,OAAO,CAAC,CAAC;IACxC,CAAC,CAAC;EACJ,CAAC,MAAM,IAAI,OAAOG,OAAO,KAAK,QAAQ,EAAE;IACtC;IACA;IACA;IACAC,MAAM,CAACD,OAAO,GAAGH,OAAO,CAAC,CAAC;EAC5B,CAAC,MAAM;IACLD,IAAI,CAAC,YAAY,CAAC,GAAGC,OAAO,CAAC,CAAC;EAChC;AACF,CAAC,EAAC,IAAI,EAAE,YAAY;EAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAIK,UAAU,GAAG,SAAAA,CAAUC,GAAG,EAAG;IAChCD,UAAU,CAACE,IAAI,CAACC,MAAM,CAAE,IAAI,EAAEF,GAAI,CAAC,CAAC,CAAE;;IAEtC;IACA,IAAIG,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIA,OAAO,KAAK,KAAK,IAAIA,OAAO,KAAK,SAAS,IAAIA,OAAO,KAAK,UAAU,IAAIA,OAAO,KAAK,WAAW,EAAG;MACrG,MAAM,IAAIC,KAAK,CAAE,kCAAmC,CAAC;IACtD;EACD,CAAC;EAEDL,UAAU,CAACM,SAAS,GAAG;IACtBC,WAAW,EAAGP,UAAU;IAAG;;IAE3B;AACD;AACA;AACA;AACA;IACCQ,IAAI,EAAG,IAAI;IAEX;AACD;AACA;AACA;AACA;IACCC,KAAK,EAAG,IAAI;IAEZ;AACD;AACA;AACA;AACA;IACCC,OAAO,EAAG,IAAI;IAEd;AACD;AACA;AACA;AACA;IACCC,KAAK,EAAE,IAAI;IAEX;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACCP,OAAO,EAAG,KAAK;IAEf;AACD;AACA;AACA;AACA;IACCQ,SAAS,EAAG,IAAI;IAEhB;AACD;AACA;AACA;AACA;AACA;IACCC,WAAW,EAAG,IAAI;IAElB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACCC,QAAQ,EAAGC,SAAS;IAEpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACCC,SAAS,EAAG,EAAE;IAEd;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAGC;AACD;AACA;AACA;AACA;AACA;AACA;IACCC,UAAU,EAAGF,SAAS;IAEtB;AACD;AACA;AACA;AACA;AACA;AACA;IACCG,WAAW,EAAGH,SAAS;IAEvB;AACD;AACA;AACA;AACA;AACA;AACA;IACCI,UAAU,EAAGJ,SAAS;IAEtB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACCK,IAAI,EAAG,SAAAA,CAAUC,UAAU,EAAG;MAC7B,IAAI,CAACA,UAAU,EAAG;QAAE,OAAO,EAAE;MAAE,CAAC,CAAE;;MAElC,IAAIJ,UAAU,GAAG,IAAI,CAACK,aAAa,CAAC,CAAC;QACjCC,SAAS,GAAGN,UAAU,CAACO,KAAK,CAAEH,UAAW,CA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I,GAAG,CAACqC,SAAS,CAAES,OAAQ,CAAE,CAAC;MAEvC,OAAOD,MAAM;IACd,CAAC;IAGD;AACD;AACA;AACA;AACA;AACA;IACCI,IAAI,EAAG,SAAAA,CAAUjD,GAAG,EAAG;MACtB,OAAOA,GAAG,CAACE,OAAO,CAAE,IAAI,CAACkB,SAAS,EAAE,EAAG,CAAC;IACzC;EAED,CAAC;EACD;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA/D,UAAU,CAACoD,OAAO,GAAGpD,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEyB,MAAM,EAAE;IAEpD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;IAEC;AACD;AACA;AACA;AACA;AACA;;IAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEC;AACD;AACA;AACA;AACA;AACA;;IAGC;AACD;AACA;AACA;AACA;AACA;IACCC,eAAe,EAAG,KAAK;IAGvB;AACD;AACA;AACA;IACCvF,WAAW,EAAG,SAAAA,CAAUN,GAAG,EAAG;MAC7BD,UAAU,CAACE,IAAI,CAACC,MAAM,CAAE,IAAI,EAAEF,GAAI,CAAC;MAEnC,IAAI,CAAC8F,SAAS,GAAG,IAAI,CAACA,SAAS,IAAI,IAAI,CAACC,SAAS,CAAC,CAAE;IACrD,CAAC;IAGD;AACD;AACA;AACA;AACA;AACA;IACCC,UAAU,EAAG,SAAAA,CAAUC,OAAO,EAAG;MAChC,IAAI,CAACA,OAAO,GAAGA,OAAO;MACtB,OAAO,IAAI;IAC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9D,SAAS,EAAG,SAAAA,CAAA,EAAW;MACtB,OAAO,IAAI,CAACsI,OAAO;IACpB;EAED,CAAE,CAAC;EACH;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA1K,UAAU,CAACiB,UAAU,CAAC0J,UAAU,GAAG3K,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEpE,UAAU,CAACiB,UAAU,CAAC4J,QAAQ,EAAE;IAE1F;AACD;AACA;AACA;AACA;IACC7I,OAAO,EAAG,SAAAA,CAAA,EAAW;MACpB,OAAO,QAAQ;IAChB;EAED,CAAE,CAAC;EACH;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAhC,UAAU,CAACiB,UAAU,CAAC2J,QAAQ,GAAG5K,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEpE,UAAU,CAACiB,UAAU,CAAC4J,QAAQ,EAAE;IAExF;AACD;AACA;AACA;AACA;IACC7I,OAAO,EAAG,SAAAA,CAAA,EAAW;MACpB,OAAO,MAAM;IACd;EAED,CAAE,CAAC;EACH;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAhC,UAAU,CAACkB,WAAW,CAACwC,WAAW,GAAG1D,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEyB,MAAM,EAAE;IAEpE;AACD;AACA;AACA;IACCrF,IAAI,EAAG,IAAI;IAEX;AACD;AACA;AACA;IACCC,KAAK,EAAG,IAAI;IAEZ;AACD;AACA;AACA;IACCC,OAAO,EAAG,IAAI;IAEd;AACD;AACA;AACA;IACCC,KAAK,EAAE,IAAI;IAEX;AACD;AACA;AACA;IACCP,OAAO,EAAG,KAAK;IAEf;AACD;AACA;AACA;IACCS,WAAW,EAAG,IAAI;IAGlB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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ACA;AACA;AACA;AACA;AACA;IACC0C,8BAA8B,EAAG,SAAAA,CAAUnC,qBAAqB,EAAG;MAClE,OAAS,CAAC,CAACA,qBAAqB,IAAI,IAAI,CAAC4B,4BAA4B,CAACD,IAAI,CAAE3B,qBAAsB,CAAC;IACpG;EAED,CAAE,CAAC;;EAEH;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA3N,UAAU,CAAC+C,KAAK,CAACkN,KAAK,GAAGjQ,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEyB,MAAM,EAAE;IAExD;AACD;AACA;AACA;AACA;;IAGC;AACD;AACA;AACA;IACCtF,WAAW,EAAG,SAAAA,CAAUN,GAAG,EAAG;MAC7BD,UAAU,CAACE,IAAI,CAACC,MAAM,CAAE,IAAI,EAAEF,GAAI,CAAC;IACpC,CAAC;IAGD;AACD;AACA;AACA;AACA;AACA;IACC+B,OAAO,EAAGhC,UAAU,CAACE,IAAI,CAAC4D,cAAc;IAGxC;AACD;AACA;AACA;AACA;IACCX,cAAc,EAAG,SAAAA,CAAA,EAAW;MAC3B,OAAO,IAAI,CAAC+K,WAAW;IACxB,CAAC;IAGD;AACD;AACA;AACA;AACA;AACA;IACChG,aAAa,EAAGlI,UAAU,CAACE,IAAI,CAAC4D,cAAc;IAG9C;AACD;AACA;AACA;AACA;AACA;IACCsE,aAAa,EAAGpI,UAAU,CAACE,IAAI,CAAC4D;EAEjC,CAAE,CAAC;EACH;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA9D,UAAU,CAAC+C,KAAK,CAACkL,KAAK,GAAGjO,UAAU,CAACE,IAAI,CAACkE,MAAM,CAAEpE,UAAU,CAAC+C,KAAK,CAACkN,KAAK,EAAE;IAExE;AACD;AACA;AACA;AACA;;IAGC;AACD;AACA;AACA;AACA;IACCjO,OAAO,EAAG,SAAAA,CAAA,EAAW;MACpB,OAAO,OAAO;IACf,CAAC;IAGD;AACD;AACA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}